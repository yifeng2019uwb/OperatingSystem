 ------------- test read-only file ----------------- 
 ** test fgetc for 3 time ** 
test fgetc:   Success! 
fgetc : A
test fgetc:   Success! 
fgetc : B
test fgetc:   Success! 
fgetc : C

 ** test fgets -  8 bits for 3 times ** 
fgets string: 

fgets string: 

fgets string: 


 ** test fread with 1024 numbers with each size i  ** 
 check how many bits to read every time and compare with asked read size 
 ******* The 1 time fread and read 1024 bits ********
DEFGHIJKLMNOPQ
0



Assignment 3: Standard I/O Library
Original author: Munehiro Fukuda

Revisions 2019: Morris Bernstein

As we have seen in Lab 3, the operating system calls open, close, read, write, llseek, etc. provide an effective interface to the filesystem, but have significant limitations. Performance and convenience can be dramatically improved using a higher-level userland library that provides buffering and data-formatting. Furthermore, programs that use the language-defined standard library are more likely to be portable across operating systems.

The standard I/O library of the C language is available to any C or C++ program that includes the stdio.h (cstdio in C++) header file. Since C predates the object-oriented paradigm, the FILE* object is passed in as the first argument to the various functions that implement file operations, but it is fundamentally an operation on an object.

For this assignment, you will implement a class-based version of the C standard I/O library. The constructor will o
 ********************************************* 



 ******* The 2 time fread and read 2048 bits ********
pen the file, and the destructor will close the file.

Since constructors and destructors don't return values, we have to alter the semantics slightly: if an error occurs, throw an exception.

Implement the following methods using only the underlying system calls. See the corresponding man pages. Note that the file argument is implicit in the method call, so we must alter the function signature slightly.
ferror
feof
fflush
fputc
fgetc
fgets
fputs
fseek
Do not use the C++ standard template library, C++ strings library, C standard I/O library or C standard strings functions. You may use malloc to allocate the buffer.

Behavior should be predictable even for files opened in read/write mode. For example, if you read ABC from the file, write XYZ, and then read GHI, the file should end up containing ABCXYZGHI regardless of the buffering mode. Similarly, writing ABCDEFGHI, repositioning the file pointer to the beginning of the file ("rewinding") and writing XYZ should leave XYZDEFGHI in the file regardless of the buffering mode.

Your test program should verify that writing to a read-only file is an error; reading from a write-only file is an error; and that the the code correctly handles the switch between reading and writing in read/write mode.

Your implementation need not worry about thread-safety.

For the purposes of the assignment you only need to implement the default FULL_BUFFER mode. setvbuf is unsupported.

"a" and "a+" modes have complicated semantics and need not be implemented.

You may crash the program if any unsupported feature is called. See undefined behavior.

An application using your library should #include "file.h" and link with file.o (produced by compiling file.cc with the -c flag. Simulate this by putting your implementation and test program in separate directories (use the -I flag when compiling your test program).

Repeat the benchmarking of Lab 3 for your implementation. This means you will be creating two separate executable programs that use your I/O library.

Skeletons have been provided:
 ********************************************* 



 ******* The 3 time fread and read 3072 bits ********
 file-skel.h and file-skel.cc. You may also reuse or cannibalize any of the work that you did for Lab 3.

For reference, a simplified version of fprintf has been provided in the skeleton code.

Don't forget the BUILD script and README files.


ABCDEFGHIJKLMNOPQ
1



Assignment 3: Standard I/O Library
Original author: Munehiro Fukuda

Revisions 2019: Morris Bernstein

As we have seen in Lab 3, the operating system calls open, close, read, write, llseek, etc. provide an effective interface to the filesystem, but have significant limitations. Performance and convenience can be dramatically improved using a higher-level userland library that provides buffering and data-formatting. Furthermore, programs that use the language-defined standard library are more likely to be portable across operating systems.

The standard I/O library of the C language is available to any C or C++ program that includes the stdio.h (cstdio in C++) header file. Since C predates the object-oriented paradigm, the FILE* object is passed in as the first argument to the various functions that implement file operations, but it is fundamentally an operation on an object.

For this assignment, you will implement a class-based version of the C standard I/O library. The constructor will open the file, and the destructor will close the file.

Since constructors and destructors don't return values, we have to alter the semantics slightly: if an error occurs, throw an exception.

Implement the following methods using only the underlying system calls. See the corresponding man pages. Note that the file argument is implicit in the method call, so we must alter the function signature slightly.
ferror
feof
fflush
fputc
fgetc
fgets
fputs
fseek
Do not use the C++ standard template library, C++ strings library, C standard I/O library or C standard strings functions. You may use malloc to allocate the buffer.

Behavior should be predictable even for files opened in read/write mode. For example, if you read ABC from the file, write XYZ, and then read GHI, the file should end up containing ABCXYZGHI regardless of the buffering mode. Similarly, writing ABCDEFGHI, repositioning the file pointer to the beginning of the file ("rewinding") and writing XYZ should leave XYZDEFGHI in the file regardless of the buffering mode.

Your test program should verify that writing to a read-only file is an error; reading from a write-only file is an error; and that the the code correctly handles the switch between reading and writing in read/write mode.

Your implementation need not worry about thread-safety.

For the purposes of the assignment you only need to implement the default FULL_BUFFER mode. setvbuf is unsupported.

"a" and "a+" modes have complicated semantics and need not be implemented.

You may crash the program if any unsupported feature is called. See undefined behavior.

An application using your library should #include "file.h" and link with file.o (produced by compiling file.cc with the -c flag. Simulate this by putting your implementation and test program in separat
 ********************************************* 



 ******* The 4 time fread and read 4096 bits ********
e directories (use the -I flag when compiling your test program).

Repeat the benchmarking of Lab 3 for your implementation. This means you will be creating two separate executable programs that use your I/O library.

Skeletons have been provided: file-skel.h and file-skel.cc. You may also reuse or cannibalize any of the work that you did for Lab 3.

For reference, a simplified version of fprintf has been provided in the skeleton code.

Don't forget the BUILD script and README files.


ABCDEFGHIJKLMNOPQ
2



Assignment 3: Standard I/O Library
Original author: Munehiro Fukuda

Revisions 2019: Morris Bernstein

As we have seen in Lab 3, the operating system calls open, close, read, write, llseek, etc. provide an effective interface to the filesystem, but have significant limitations. Performance and convenience can be dramatically improved using a higher-level userland library that provides buffering and data-formatting. Furthermore, programs that use the language-defined standard library are more likely to be portable across operating systems.

The standard I/O library of the C language is available to any C or C++ program that includes the stdio.h (cstdio in C++) header file. Since C predates the object-oriented paradigm, the FILE* object is passed in as the first argument to the various functions that implement file operations, but it is fundamentally an operation on an object.

For this assignment, you will implement a class-based version of the C standard I/O library. The constructor will open the file, and the destructor will close the file.

Since constructors and destructors don't return values, we have to alter the semantics slightly: if an error occurs, throw an exception.

Implement the following methods using only the underlying system calls. See the corresponding man pages. Note that the file argument is implicit in the method call, so we must alter the function signature slightly.
ferror
feof
fflush
fputc
fgetc
fgets
fputs
fseek
Do not use the C++ standard template library, C++ strings library, C standard I/O library or C standard strings functions. You may use malloc to allocate the buffer.

Behavior should be predictable even for files opened in read/write mode. For example, if you read ABC from the file, write XYZ, and then read GHI, the file should end up containing ABCXYZGHI regardless of the buffering mode. Similarly, writing ABCDEFGHI, repositioning the file pointer to the beginning of the file ("rewinding") and writing XYZ should leave XYZDEFGHI in the file regardless of the buffering mode.

Your test program should verify that writing to a read-only file is an error; reading from a write-only file is an error; and that the the code correctly handles the switch between reading and writing in read/write mode.

Your implementation need not worry about thread-safety.

For the purposes of the assignment you only need to implement the default FULL_BUFFER mode. setvbuf is unsupported.

"a" and "a+" modes have complicated semantics and need not be implemented.

You may crash the program if any unsupported feature is called. See undefined behavior.

An application using your library should #include "file.h" and link with file.o (produced by compiling file.cc with the -c flag. Simulate this by putting your implementation and test program in separate directories (use the -I flag when compiling your test program).

Repeat the benchmarking of Lab 3 for your implementation. This means you will be creating two separate executable programs that use your I/O library.

Skeletons have been provided: file-skel.h and file-skel.cc. You may also reuse or cannibalize any of the work that you did for Lab 3.

For reference, a simplified version of fprintf has been provided in the skeleton code.

Don't forget the BUILD script and README files.



ABCDEFGHIJKLMNOPQ
3



Assignment 3: Standard I/O Library
Original author: Munehiro Fukuda

Revisions 2019: Morris Bernstein

As we have seen in Lab 3, the operating system calls open, close, read, write, llseek, etc. provide an effective interface to the filesystem, but have signific
 ********************************************* 



 ******* The 5 time fread and read 5120 bits ********
ant limitations. Performance and convenience can be dramatically improved using a higher-level userland library that provides buffering and data-formatting. Furthermore, programs that use the language-defined standard library are more likely to be portable across operating systems.

The standard I/O library of the C language is available to any C or C++ program that includes the stdio.h (cstdio in C++) header file. Since C predates the object-oriented paradigm, the FILE* object is passed in as the first argument to the various functions that implement file operations, but it is fundamentally an operation on an object.

For this assignment, you will implement a class-based version of the C standard I/O library. The constructor will open the file, and the destructor will close the file.

Since constructors and destructors don't return values, we have to alter the semantics slightly: if an error occurs, throw an exception.

Implement the following methods using only the underlying system calls. See the corresponding man pages. Note that the file argument is implicit in the method call, so we must alter the function signature slightly.
ferror
feof
fflush
fputc
fgetc
fgets
fputs
fseek
Do not use the C++ standard template library, C++ strings library, C standard I/O library or C standard strings functions. You may use malloc to allocate the buffer.

Behavior should be predictable even for files opened in read/write mode. For example, if you read ABC from the file, write XYZ, and then read GHI, the file should end up containing ABCXYZGHI regardless of the buffering mode. Similarly, writing ABCDEFGHI, repositioning the file pointer to the beginning of the file ("rewinding") and writing XYZ should leave XYZDEFGHI in the file regardless of the buffering mode.

Your test program should verify that writing to a read-only file is an error; reading from a write-only file is an error; and that the the code correctly handles the switch between reading and writing in read/write mode.

Your implementation need not worry about thread-safety.

For the purposes of the assignment you only need to implement the default FULL_BUFFER mode. setvbuf is unsupported.

"a" and "a+" modes have complicated semantics and need not be implemented.

You may crash the program if any unsupported feature is called. See undefined behavior.

An application using your library should #include "file.h" and link with file.o (produced by compiling file.cc with the -c flag. Simulate this by putting your implementation and test program in separate directories (use the -I flag when compiling your test program).

Repeat the benchmarking of Lab 3 for your implementation. This means you will be creating two separate executable programs that use your I/O library.

Skeletons have been provided: file-skel.h and file-skel.cc. You may also reuse or cannibalize any of the work that you did for Lab 3.

For reference, a simplified version of fprintf has been provided in the skeleton code.

Don't forget the BUILD script and README files.


ABCDEFGHIJKLMNOPQ
4



Assignment 3: Standard I/O Library
Original author: Munehiro Fukuda

Revisions 2019: Morris Bernstein

As we have seen in Lab 3, the operating system calls open, close, read, write, llseek, etc. provide an effective interface to the filesystem, but have significant limitations. Performance and convenience can be dramatically improved using a higher-level userland library that provides buffering and data-formatting. Furthermore, programs that use the language-defined standard library are more likely to be portable across operating systems.

The standard I/O library of the C language is available to any C or C++ program that includes the stdio.h (cstdio in C++) header file. Since C predates the object-oriented paradigm, the FILE* object is passed in as the first argument to the various functions that implement file operations, but it is fundamentally an operation on an object.

For this assignment, you will implement a class-based version of the C standard I/O library. The constructor will open the file, and the destructor will close the file.

Since constructors and destructors don't return values, we have to alter the semantics slightly: if an error occurs, throw an exception.

Implement the following methods using only the underlying system calls. See the corresponding man pages. Note that the file argument is implicit in the method call, so we must alter the function signature slightly.
ferror
feof
fflush
fputc
fgetc
fgets
fputs
fseek
Do not use the C++ standard template library, C++ strings library, C standard I/O library or C standard strings functions. You may use malloc to allocate the buffer.

Behavior should be predictable even for files opened in read/write mode. For example, if you read ABC from the file, write XYZ, and then read GHI, the file should end up containing ABCXYZGHI regardless of the buffering mode. Similarly, writing ABCDEFGHI, repositioning the file pointer to the beginning of the file ("rewinding") and writing XYZ should leave XYZDEFGHI in the file regardless of the buffering mode.

Your test program sh
 ********************************************* 



 ******* The 6 time fread and read 6144 bits ********
ould verify that writing to a read-only file is an error; reading from a write-only file is an error; and that the the code correctly handles the switch between reading and writing in read/write mode.

Your implementation need not worry about thread-safety.

For the purposes of the assignment you only need to implement the default FULL_BUFFER mode. setvbuf is unsupported.

"a" and "a+" modes have complicated semantics and need not be implemented.

You may crash the program if any unsupported feature is called. See undefined behavior.

An application using your library should #include "file.h" and link with file.o (produced by compiling file.cc with the -c flag. Simulate this by putting your implementation and test program in separate directories (use the -I flag when compiling your test program).

Repeat the benchmarking of Lab 3 for your implementation. This means you will be creating two separate executable programs that use your I/O library.

Skeletons have been provided: file-skel.h and file-skel.cc. You may also reuse or cannibalize any of the work that you did for Lab 3.

For reference, a simplified version of fprintf has been provided in the skeleton code.

Don't forget the BUILD script and README files.


ABCDEFGHIJKLMNOPQ
5



Assignment 3: Standard I/O Library
Original author: Munehiro Fukuda

Revisions 2019: Morris Bernstein

As we have seen in Lab 3, the operating system calls open, close, read, write, llseek, etc. provide an effective interface to the filesystem, but have significant limitations. Performance and convenience can be dramatically improved using a higher-level userland library that provides buffering and data-formatting. Furthermore, programs that use the language-defined standard library are more likely to be portable across operating systems.

The standard I/O library of the C language is available to any C or C++ program that includes the stdio.h (cstdio in C++) header file. Since C predates the object-oriented paradigm, the FILE* object is passed in as the first argument to the various functions that implement file operations, but it is fundamentally an operation on an object.

For this assignment, you will implement a class-based version of the C standard I/O library. The constructor will open the file, and the destructor will close the file.

Since constructors and destructors don't return values, we have to alter the semantics slightly: if an error occurs, throw an exception.

Implement the following methods using only the underlying system calls. See the corresponding man pages. Note that the file argument is implicit in the method call, so we must alter the function signature slightly.
ferror
feof
fflush
fputc
fgetc
fgets
fputs
fseek
Do not use the C++ standard template library, C++ strings library, C standard I/O library or C standard strings functions. You may use malloc to allocate the buffer.

Behavior should be predictable even for files opened in read/write mode. For example, if you read ABC from the file, write XYZ, and then read GHI, the file should end up containing ABCXYZGHI regardless of the buffering mode. Similarly, writing ABCDEFGHI, repositioning the file pointer to the beginning of the file ("rewinding") and writing XYZ should leave XYZDEFGHI in the file regardless of the buffering mode.

Your test program should verify that writing to a read-only file is an error; reading from a write-only file is an error; and that the the code correctly handles the switch between reading and writing in read/write mode.

Your implementation need not worry about thread-safety.

For the purposes of the assignment you only need to implement the default FULL_BUFFER mode. setvbuf is unsupported.

"a" and "a+" modes have complicated semantics and need not be implemented.

You may crash the program if any unsupported feature is called. See undefined behavior.

An application using your library should #include "file.h" and link with file.o (produced by compiling file.cc with the -c flag. Simulate this by putting your implementation and test program in separate directories (use the -I flag when compiling your test program).

Repeat the benchmarking of Lab 3 for your implementation. This means you will be creating two separate executable programs that use your I/O library.

Skeletons have been provided: file-skel.h and file-skel.cc. You may also reuse or cannibalize any of the work that you did for Lab 3.

For reference, a simplified version of fprintf has been provided in the skeleton code.

Don't forget the BUILD script and README files.


ABCDEFGHIJKLMNOPQ
6



Assignment 3: Standard I/O Library
Original author: Munehiro Fukuda

Revisions 2019: Morris Bernstein

As we have seen in Lab 3, the operating system calls open, close, read, write, llseek, etc. provide an effective interface to the filesystem, but have significant limitations. Performance and convenience can be dramatically improved using a higher-level userland library that provides buffering and data-formatting. Furthermore, programs that use the language-defined standard library are more likely to be portable across operating systems.

The standard I/O library of the C language is available to any C or C++ program that includes the stdio.h (cstdio in C++) header file. Since C predates the object-oriented paradigm, the FILE* object is passed in as the first argument to the various functions that implement file operations, but it is fundamentally an operation on an object.

For this assignment, you will implement a class-based version of the C standard I/O library. The constructor will open the file, and the destructor will close the file.

Since constructors and destructors don't return values, we have to alter the semantics slightly: if an error occurs, throw an exception.

Implement the following methods using only the underlying system calls. See the corresponding man pages. Note that the file argument is implicit in the method call, so we must alter the function signature slightly.
ferror
feof
fflush
fputc
fgetc
fgets
fputs
fseek
Do not use the C++ standard template library, C++ strings library, C standard I/O library or C standard stri
 ********************************************* 



 ******* The 7 time fread and read 7168 bits ********
ngs functions. You may use malloc to allocate the buffer.

Behavior should be predictable even for files opened in read/write mode. For example, if you read ABC from the file, write XYZ, and then read GHI, the file should end up containing ABCXYZGHI regardless of the buffering mode. Similarly, writing ABCDEFGHI, repositioning the file pointer to the beginning of the file ("rewinding") and writing XYZ should leave XYZDEFGHI in the file regardless of the buffering mode.

Your test program should verify that writing to a read-only file is an error; reading from a write-only file is an error; and that the the code correctly handles the switch between reading and writing in read/write mode.

Your implementation need not worry about thread-safety.

For the purposes of the assignment you only need to implement the default FULL_BUFFER mode. setvbuf is unsupported.

"a" and "a+" modes have complicated semantics and need not be implemented.

You may crash the program if any unsupported feature is called. See undefined behavior.

An application using your library should #include "file.h" and link with file.o (produced by compiling file.cc with the -c flag. Simulate this by putting your implementation and test program in separate directories (use the -I flag when compiling your test program).

Repeat the benchmarking of Lab 3 for your implementation. This means you will be creating two separate executable programs that use your I/O library.

Skeletons have been provided: file-skel.h and file-skel.cc. You may also reuse or cannibalize any of the work that you did for Lab 3.

For reference, a simplified version of fprintf has been provided in the skeleton code.

Don't forget the BUILD script and README files.


ABCDEFGHIJKLMNOPQ
7



Assignment 3: Standard I/O Library
Original author: Munehiro Fukuda

Revisions 2019: Morris Bernstein

As we have seen in Lab 3, the operating system calls open, close, read, write, llseek, etc. provide an effective interface to the filesystem, but have significant limitations. Performance and convenience can be dramatically improved using a higher-level userland library that provides buffering and data-formatting. Furthermore, programs that use the language-defined standard library are more likely to be portable across operating systems.

The standard I/O library of the C language is available to any C or C++ program that includes the stdio.h (cstdio in C++) header file. Since C predates the object-oriented paradigm, the FILE* object is passed in as the first argument to the various functions that implement file operations, but it is fundamentally an operation on an object.

For this assignment, you will implement a class-based version of the C standard I/O library. The constructor will open the file, and the destructor will close the file.

Since constructors and destructors don't return values, we have to alter the semantics slightly: if an error occurs, throw an exception.

Implement the following methods using only the underlying system calls. See the corresponding man pages. Note that the file argument is implicit in the method call, so we must alter the function signature slightly.
ferror
feof
fflush
fputc
fgetc
fgets
fputs
fseek
Do not use the C++ standard template library, C++ strings library, C standard I/O library or C standard strings functions. You may use malloc to allocate the buffer.

Behavior should be predictable even for files opened in read/write mode. For example, if you read ABC from the file, write XYZ, and then read GHI, the file should end up containing ABCXYZGHI regardless of the buffering mode. Similarly, writing ABCDEFGHI, repositioning the file pointer to the beginning of the file ("rewinding") and writing XYZ should leave XYZDEFGHI in the file regardless of the buffering mode.

Your test program should verify that writing to a read-only file is an error; reading from a write-only file is an error; and that the the code correctly handles the switch between reading and writing in read/write mode.

Your implementation need not worry about thread-safety.

For the purposes of the assignment you only need to implement the default FULL_BUFFER mode. setvbuf is unsupported.

"a" and "a+" modes have complicated semantics and need not be implemented.

You may crash the program if any unsupported feature is called. See undefined behavior.

An application using your library should #include "file.h" and link with file.o (produced by compiling file.cc with the -c flag. Simulate this by putting your implementation and test program in separate directories (use the -I flag when compiling your test program).

Repeat the benchmarking of Lab 3 for your implementation. This means you will be creating two separate executable programs that use your I/O library.

Skeletons have been provided: file-skel.h and file-skel.cc. You may also reuse or cannibalize any of the work that you did for Lab 3.

For reference, a simplified version of fprintf has been provided in the skeleton code.

Don't forget the BUILD script and README files.


ABCDEFGHIJKLMNOPQ
8



Assignment 3: Standard I/O Library
Original author: Munehiro Fukuda

Revisions 2019: Morris Bernstein

As we have seen in Lab 3, the operating system calls open, close, read, write, llseek, etc. provide an effective interface to the filesystem, but have significant limitations. Performance and convenience can be dramatically improved using a higher-level userland library that provides buffering and data-formatting. Furthermore, programs that use the language-defined standard library are more likely to be portable across operating systems.

The standard I/O library of the C language is available to any C or C++ program that includes the stdio.h (cstdio in C++) header file. Since C predates the object-oriented paradigm, the FILE* object is passed in as the first argument to the various functions that implement file operations, but it is fundamentally an operation on an object.

For this assignment, you will implement a class-based version of the C standard I/O library. The constructor will open the file, and the destructor will close the file.

Since constructors and destructors don't return values, we have to alter the semantics slightly: if an error occurs, throw an exception.

Implement the following methods using only the underlying system calls. See the corresponding man pages. Note that the file argument is implicit in the method call, so we must alter the function signature slightly.
ferror
feof
fflush
fputc
fgetc
fgets
fputs
fseek
Do not use the C++ standard template library, C++ strings library, C standard I/O library or C standard strings functions. You may use malloc to allocate the buffer.

Behavior should be predictable even for files opened in read/write mode. For example, if you read ABC from the file, write XYZ, and then read GHI, the file should end up containing ABCXYZGHI regardless of the buffering mode. Similarly, writing ABCDEFGHI, repositioning the file pointer to the beginning of the file ("rewinding") and writing XYZ should leave XYZDEFGHI in the file regardless of the buffering mode.

Your test program should verify that writing to a read-o
 ********************************************* 



 ******* The 8 time fread and read 8192 bits ********
epeat the benchmarking of Lab 3 for your implementation. This means you will be creating two separate executable programs that use your I/O library.

Skeletons have been provided: file-skel.h and file-skel.cc. You may also reuse or cannibalize any of the work that you did for Lab 3.

For reference, a simplified version of fprintf has been provided in the skeleton code.

Don't forget the BUILD script and README files.


ABCDEFGHIJKLMNOPQ
10



Assignment 3: Standard I/O Library
Original author: Munehiro Fukuda

Revisions 2019: Morris Bernstein

As we have seen in Lab 3, the operating system calls open, close, read, write, llseek, etc. provide an effective interface to the filesystem, but have significant limitations. Performance and convenience can be dramatically improved using a higher-level userland library that provides buffering and data-formatting. Furthermore, programs that use the language-defined standard library are more likely to be portable across operating systems.

The standard I/O library of the C language is available to any C or C++ program that includes the stdio.h (cstdio in C++) header file. Since C predates the object-oriented paradigm, the FILE* object is passed in as the first argument to the various functions that implement file operations, but it is fundamentally an operation on an object.

For this assignment, you will implement a class-based version of the C standard I/O library. The constructor will open the file, and the destructor will close the file.

Since constructors and destructors don't return values, we have to alter the semantics slightly: if an error occurs, throw an exception.

Implement the following methods using only the underlying system calls. See the corresponding man pages. Note that the file argument is implicit in the method call, so we must alter the function signature slightly.
ferror
feof
fflush
fputc
fgetc
fgets
fputs
fseek
Do not use the C++ standard template library, C++ strings library, C standard I/O library or C standard strings functions. You may use malloc to allocate the buffer.

Behavior should be predictable even for files opened in read/write mode. For example, if you read ABC from the file, write XYZ, and then read GHI, the file should end up containing ABCXYZGHI regardless of the buffering mode. Similarly, writing ABCDEFGHI, repositioning the file pointer to the beginning of the file ("rewinding") and writing XYZ should leave XYZDEFGHI in the file regardless of the buffering mode.

Your test program should verify that writing to a read-only file is an error; reading from a write-only file is an error; and that the the code correctly handles the switch between reading and writing in read/write mode.

Your implementation need not worry about thread-safety.

For the purposes of the assignment you only need to implement the default FULL_BUFFER mode. setvbuf is unsupported.

"a" and "a+" modes have complicated semantics and need not be implemented.

You may crash the program if any unsupported feature is called. See undefined behavior.

An application using your library should #include "file.h" and link with file.o (produced by compiling file.cc with the -c flag. Simulate this by putting your implementation and test program in separate directories (use the -I flag when compiling your test program).

Repeat the benchmarking of Lab 3 for your implementation. This means you will be creating two separate executable programs that use your I/O library.

Skeletons have been provided: file-skel.h and file-skel.cc. You may also reuse or cannibalize any of the work that you did for Lab 3.

For reference, a simplified version of fprintf has been provided in the skeleton code.

Don't forget the BUILD script and README files.

ABCDEFGHIJKLMNOPQ
11


Assignment 3: Standard I/O Library
Original author: Munehiro Fukuda

Revisions 2019: Morris Bernstein

As we have seen in Lab 3, the operating system calls open, close, read, write, llseek, etc. provide an effective interface to the filesystem, but have significant limitations. Performance and convenience can be dramatically improveignment you only need to implement the default FULL_BUFFER mode. setvbuf is unsupported.

"a" and "a+" modes have complicated semantics and need not be implemented.

You may crash the program if any unsupported feature is called. See undefined behavior.

An application using your library should #include "file.h" and link with file.o (produced by compiling file.cc with the -c flag. Simulate this by putting your implementation and test program in separate directories (use the -I flag when compiling your test program).

Repeat the benchmarking of Lab 3 for your implementation. This means you will be creating two separate executable programs that use your I/O library.

Skeletons have been provided: file-skel.h and file-skel.cc. You may also reuse or cannibalize any of the work that you did for Lab 3.

For reference, a simplified version of fprintf has been provided in the skeleton code.

Don't forget the BUILD script and README files.


ABCDEFGHIJKLMNOPQ
8



Assignment 3: Standard I/O Library
Original author: Munehiro Fukuda

Revisions 2019: Morris Bernstein

As we have seen in Lab 3, the operating system calls open, close, read, write, llseek, etc. provide an effective interface to the filesystem, but have significant limitations. Performance and convenience can be dramatically improved using a higher-level userland library that provides buffering and data-formatting. Furthermore, programs that use the language-defined standard library are more likely to be portable across operating systems.

The standard I/O library of the C language is available to any C or C++ program that includes the stdio.h (cstdio in C++) header file. Since C predates the object-oriented paradigm, the FILE* object is passed in as the first argument to the various functions that implement file operations, but it is fundamentally an operation on an object.

For this assignment, you will implement a class-based version of the C standard I/O library. The constructor will open the file, and the destructor will close the file.

Since constructors and destructors don't return values, we have to alter the semantics slightly: if an error occurs, throw an exception.

Implement the following methods using only the underlying system calls. See the corresponding man pages. Note that the file argument is implicit in the method call, so we must alter the function signature slightly.
ferror
feof
fflush
fputc
fgetc
fgets
fputs
fseek
Do not use the C++ standard template library, C++ strings library, C standard I/O library or C standard strings functions. You may use malloc to allocate the buffer.

Behavior should be predictable even for files opened in read/write mode. For example, if you read ABC from the file, write XYZ, and then read GHI, the file should end up containing ABCXYZGHI regardless of the buffering mode. Similarly, writing ABCDEFGHI, repositioning the file pointer to the beginning of the file ("rewinding") and writing XYZ should leave XYZDEFGHI in the file regardless of the buffering mode.

Your test program should verify that writing to a read-o
 ********************************************* 



 ******* The 9 time fread and read 9216 bits ********
d using a higher-level userland library that provides buffering and data-formatting. Furthermore, programs that use the language-defined standard library are more likely to be portable across operating systems.

The standard I/O library of the C language is available to any C or C++ program that includes the stdio.h (cstdio in C++) header file. Since C predates the object-oriented paradigm, the FILE* object is passed in as the first argument to the various functions that implement file operations, but it is fundamentally an operation on an object.

For this assignment, you will implement a class-based version of the C standard I/O library. The constructor will open the file, and the destructor will close the file.

Since constructors and destructors don't return values, we have to alter the semantics slightly: if an error occurs, throw an exception.

Implement the following methods using only the underlying system calls. See the corresponding man pages. Note that the file argument is implicit in the method call, so we must alter the function signature slightly.
ferror
feof
fflush
fputc
fgetc
fgets
fputs
fseek
Do not use the C++ standard template library, C++ strings library, C standard I/O library or C standard strings functions. You may use malloc to allocate the buffer.

Behavior should be predictable even for files opened in read/write mode. For example, if you read ABC from the file, write XYZ, and then read GHI, the file should end up containing ABCXYZGHI regardless of the buffering mode. Similarly, writing ABCDEFGHI, repositioning the file pointer to the beginning of the file ("rewinding") and writing XYZ should leave XYZDEFGHI in the file regardless of the buffering mode.

Your test program should verify that writing to a read-only file is an error; reading from a write-only file is an error; and that the the code correctly handles the switch between reading and writing in read/write mode.

Your implementation need not worry about thread-safety.

For the purposes of the assignment you only need to implement the default FULL_BUFFER mode. setvbuf is unsupported.

"a" and "a+" modes have complicated semantics and need not be implemented.

You may crash the program if any unsupported feature is called. See undefined behavior.

An application using your library should #include "file.h" and link with file.o (produced by compiling file.cc with the -c flag. Simulate this by putting your implementation and test program in separate directories (use the -I flag when compiling your test program).

Repeat the benchmarking of Lab 3 for your implementation. This means you will be creating two separate executable programs that use your I/O library.

Skeletons have been provided: file-skel.h and file-skel.cc. You may also reuse or cannibalize any of the work that you did for Lab 3.

For reference, a simplified version of fprintf has been provided in the skeleton code.

Don't forget the BUILD script and README files.


ABCDEFGHIJKLMNOPQ
12


Assignment 3: Standard I/O Library
Original author: Munehiro Fukuda

Revisions 2019: Morris Bernstein

As we have seen in Lab 3, the operating system calls open, close, read, write, llseek, etc. provide an effective interface to the filesystem, but have significant limitations. Performance and convenience can be dramatically improved using a higher-level userland library that provides buffering and data-formatting. Furthermore, programs that use the language-defined standard library are more likely to be portable across operating systems.

The standard I/O library of the C language is available to any C or C++ program that includes the stdio.h (cstdio in C++) header file. Since C predates the object-oriented paradigm, the FILE* object is passed in as the first argument to the various functions that implement file operations, but it is fundamentally an operation on an object.

For this assignment, you will implement a class-based version of the C standard I/O library. The constructor will open the file, and the destructor will close the file.

Since constructors and destructors don't return values, we have to alter the semantics slightly: if an error occurs, throw an exception.

Implement the following methods using only the underlying system calls. See the corresponding man pages. Note that the file argument is implicit in the method call, so we must alter the function signature slightly.
ferror
feof
fflush
fputc
fgetc
fgets
fputs
fseek
Do not use the C++ standard template library, C++ strings library, C standard I/O library or C standard strings functions. You may use malloc to allocate the buffer.

Behavior should be predictable even for files opened in read/write mode. For example, if you read ABC from the file, write XYZ, and then read GHI, the file should end up containing ABCXYZGHI regardless of the buffering mode. Similarly, writing ABCDEFGHI, repositioning the file pointer to the beginning of the file ("rewinding") and writing XYZ should leave XYZDEFGHI in the file regardless of the buffering mode.

Your test program should verify that writing to a read-only file is an error; reading from a write-only file is an error; and that the the code correctly handles the switch between reading and writing in read/write mode.

Your implementation need not worry about thread-safety.

For the purposes of the assignment you only need to implement the default FULL_BUFFER mode. setvbuf is unsupported.

"a" and "a+" modes have complicated semantics and need not be implemented.

You may crash the program if any unsupported feature is called. See undefined behavior.

An application using your library should #include "file.h" and link with file.o (produced by compiling file.cc with the -c flag. Simulate this by putting your implementation and test program in separate directories (use the -I flag when compiling your test program).

Repeat the benchmarking of Lab 3 for your implementation. This means you will be creating two separate executable programs that use your I/O library.

Skeletons have been provided: file-skel.h and file-skel.cc. You may also reuse or cannibalize any of the work that you did for Lab 3.

For reference, a simplified version of fprintf has been provided in the skeleton code.

Don't forget the BUILD script and README files.


ABCDEFGHIJKLMNOPQ
13


Assignment 3: Standard I/O Library
Original author: Munehiro Fukuda

Revisions 2019: Morris Bernstein

As we have seen in Lab 3, the operating system calls open, close, read, write, llseek, etc. provide an effective interface to the filesystem, but have significant limitations. Performance and convenience can be dramatically improved using a higher-level userland library that provides buffering and data-formatting. Furthermore, programs that use the language-defined standard library are more likely to be portable across operating systems.

The standard I/O library of the C language is available to any C or C++ program that includes the stdio.h (cstdio in C++) header file. Since C predates the object-oriented paradigm, the FILE* object is passed in as the first argument to the various functions that implement file operations, but it is fundamentally an operation on an object.

For this assignment, you will implement a class-based version of the C standard I/O library. The constructor will open the file, and the destructor will close the file.

Since constructors and destructors don't return values, we have to alter the semantics slightly: if an error occurs, throw an exception.

Implement the following methods using only the underlying system calls. See the corresponding man pages. Note that the file argument is implicit in the method call, so we must alter the function signature slightly.
ferror
feof
fflush
fputc
fgetc
fgets
fputs
fseek
Do not use the C++ standard template library, C++ strings library, C standard I/O library or C standard strings functions. You may use malloc to allocate the buffer.

Behavior should be predictable even for files opened in read/write mode. For example, if you read ABC from the file, write XYZ, and then read GHI, the file should end up containing ABCXYZGHI regardless of the buffering mode. Similarly, writing ABCDEFGHI, repositioning the file pointer to the beginning of the file ("rewinding") and writing XYZ should leave XYZDEFGHI in the file regardless of the buffering mode.

Your test program should verify that writing to a read-only file is an error; reading from a write-only file is an error; and that the the code correctly handles the switch between reading and writing in read/write mode.

Your implementation need not worry about thread-safety.

For the purposes of the assignment you only need to implement the default FULL_BUFFER mode. setvbuf is unsupported.

"a" and "a+" modes have complicated semantics and need not be implemented.

You may crash the program if any unsupported feature is called. See undefined behavior.

An application using your library should #include "file.h" and link with file.o (produced by compiling file.cc with the -c flag. Simulate this by putting your implementation and test program in separate directories (use the -I flag when compiling your test program).

Repeat the benchmarking of Lab 3 for you
 ********************************************* 



 ******* The 10 time fread and read 10240 bits ********
r implementation. This means you will be creating two separate executable programs that use your I/O library.

Skeletons have been provided: file-skel.h and file-skel.cc. You may also reuse or cannibalize any of the work that you did for Lab 3.

For reference, a simplified version of fprintf has been provided in the skeleton code.

Don't forget the BUILD script and README files.


ABCDEFGHIJKLMNOPQ
14


Assignment 3: Standard I/O Library
Original author: Munehiro Fukuda

Revisions 2019: Morris Bernstein

As we have seen in Lab 3, the operating system calls open, close, read, write, llseek, etc. provide an effective interface to the filesystem, but have significant limitations. Performance and convenience can be dramatically improved using a higher-level userland library that provides buffering and data-formatting. Furthermore, programs that use the language-defined standard library are more likely to be portable across operating systems.

The standard I/O library of the C language is available to any C or C++ program that includes the stdio.h (cstdio in C++) header file. Since C predates the object-oriented paradigm, the FILE* object is passed in as the first argument to the various functions that implement file operations, but it is fundamentally an operation on an object.

For this assignment, you will implement a class-based version of the C standard I/O library. The constructor will open the file, and the destructor will close the file.

Since constructors and destructors don't return values, we have to alter the semantics slightly: if an error occurs, throw an exception.

Implement the following methods using only the underlying system calls. See the corresponding man pages. Note that the file argument is implicit in the method call, so we must alter the function signature slightly.
ferror
feof
fflush
fputc
fgetc
fgets
fputs
fseek
Do not use the C++ standard template library, C++ strings library, C standard I/O library or C standard strings functions. You may use malloc to allocate the buffer.

Behavior should be predictable even for files opened in read/write mode. For example, if you read ABC from the file, write XYZ, and then read GHI, the file should end up containing ABCXYZGHI regardless of the buffering mode. Similarly, writing ABCDEFGHI, repositioning the file pointer to the beginning of the file ("rewinding") and writing XYZ should leave XYZDEFGHI in the file regardless of the buffering mode.

Your test program should verify that writing to a read-only file is an error; reading from a write-only file is an error; and that the the code correctly handles the switch between reading and writing in read/write mode.

Your implementation need not worry about thread-safety.

For the purposes of the assignment you only need to implement the default FULL_BUFFER mode. setvbuf is unsupported.

"a" and "a+" modes have complicated semantics and need not be implemented.

You may crash the program if any unsupported feature is called. See undefined behavior.

An application using your library should #include "file.h" and link with file.o (produced by compiling file.cc with the -c flag. Simulate this by putting your implementation and test program in separate directories (use the -I flag when compiling your test program).

Repeat the benchmarking of Lab 3 for your implementation. This means you will be creating two separate executable programs that use your I/O library.

Skeletons have been provided: file-skel.h and file-skel.cc. You may also reuse or cannibalize any of the work that you did for Lab 3.

For reference, a simplified version of fprintf has been provided in the skeleton code.

Don't forget the BUILD script and README files.


ABCDEFGHIJKLMNOPQ
15


Assignment 3: Standard I/O Library
Original author: Munehiro Fukuda

Revisions 2019: Morris Bernstein

As we have seen in Lab 3, the operating system calls open, close, read, write, llseek, etc. provide an effective interface to the filesystem, but have significant limitations. Performance and convenience can be dramatically improved using a higher-level userland library that provides buffering and data-formatting. Furthermore, programs that use the language-defined standard library are more likely to be portable across operating systems.

The standard I/O library of the C language is available to any C or C++ program that includes the stdio.h (cstdio in C++) header file. Since C predates the object-oriented paradigm, the FILE* object is passed in as the first argument to the various functions that implement file operations, but it is fundamentally an operation on an object.

For this assignment, you will implement a class-based version of the C standard I/O library. The constructor will open the file, and the destructor will close the file.

Since constructors and destructors don't return values, we have to alter the semantics slightly: if an error occurs, throw an exception.

Implement the following methods using only the underlying system calls. See the corresponding man pages. Note that the file argument is implicit in the method call, so we must alter the function signature slightly.
ferror
feof
fflush
fputc
fgetc
fgets
fputs
fseek
Do not use the C++ standard template library, C++ strings library, C standard I/O library or C standard strings functions. You may use malloc to allocate the buffer.

Behavior should be predictable even for files opened in read/write mode. For example, if you read ABC from the file, write XYZ, and then read GHI, the file should end up containing ABCXYZGHI regardless of the buffering mode. Similarly, writing ABCDEFGHI, repositioning the file pointer to the beginning of the file ("rewinding") and writing XYZ should leave XYZDEFGHI in the file regardless of the buffering mode.

Your test program should verify that writing to a read-only file is an error; reading from a write-only file is an error; and that the the code correctly handles the switch between reading and writing in read/write mode.

Your implementation need not worry about thread-safety.

For the purposes of the assignment you only need to implement the default FULL_BUFFER mode. setvbuf is unsupported.

"a" and "a+" modes have complicated semantics and need not be implemented.

You may crash the program if any unsupported feature is called. See undefined behavior.

An application using your library should #include "file.h" and link with file.o (produced by compiling file.cc with the -c flag. Simulate this by putting your implementation and test program in separate directories (use the -I flag when compiling your test program).

Repeat the benchmarking of Lab 3 for your implementation. This means you will be creating two separate executable programs that use your I/O library.

Skeletons have been provided: file-skel.h and file-skel.cc. You may also reuse or cannibalize any of the work that you did for Lab 3.

For reference, a simplified version of fprintf has been provided in the skeleton code.

Don't forget the BUILD script and README files.


ABCDEFGHIJKLMNOPQ
16


Assignment 3: Standard I/O Library
Original author: Munehiro Fukuda

Revisions 2019: Morris Bernstein

As we have seen in Lab 3, the operating system calls open, close, read, write, llseek, etc. provide an effective interface to the filesystem, but have significant limitations. Performance and convenience can be dramatically improved using a higher-level userland library that provides buffering and data-formatting. Furthermore, programs that use the language-defined standard library are more likely to be portable across operating systems.

The standard I/O library of the C language is available to any C or C++ program that includes the stdio.h (cstdio in C++) header file. Since C predates the object-oriented paradigm, the FILE* object is passed in as the first argument to the various functions that implement file operations, but it is fundamentally an operation on an object.

For this assignment, you will implement a class-based version of the C standard I/O library. The constructor will open the file, and the destructor will close the file.

Since constructors and destructors don't return values, we have to alter the semantics slightly: if an error occurs, throw an exception.

Implement the following methods using only the underlying system calls. See the corresponding man pages. Note that the file argument is implicit in the method call, so we must alter the function signature slightly.
ferror
feof
fflush
fputc
fgetc
fgets
fputs
fseek
Do not use the C++ standard template library, C++ strings library, C standard I/O library or C standard strings functions. You may use malloc to allocate the buffer.

Behavior should be predictable even for files opened in read/write mode. For example, if you read ABC from the file, write XYZ, and then read GHI, the file should end up containing ABCXYZGHI regardless of the buffering mode. Similarly, writing ABCDEFGHI, repositioning the file pointer to the beginning of the file ("rewinding") and writing XYZ should leave XYZDEFGHI in the file regardless of the buffering mode.

Your test program should verify that writing to a read-only file is an error; reading from a write-only file is an error; and that the the code correctly handles the switch between reading and writing in read/write mode.

Your implementation need not worry about thread-safety.

For the purposes of the assignment you only need to implement the default FULL_BUFFER mode. setvbuf is unsupported.

"a" and "a+" modes have complicated semantics and need not be implemented.

You may crash the program if any unsupported feature is called. See undefined behavior.

An application using your library should #include "file.h" and link with file.o (produced by compiling file.cc with the -c flag. Simulate this by putting your implementation and test program in separate directories (use the -I flag when compiling your test program).

Repeat the benchmarking of Lab 3 for your implementation. This means you will be creating two separate executable programs that use your I/O library.

Skeletons have been provided: file-skel.h and file-skel.cc. You may also reuse or cannibalize any of the work that you did for Lab 3.

For reference, a simplified version o
 ********************************************* 



 ******* The 11 time fread and read 11264 bits ********
f fprintf has been provided in the skeleton code.

Don't forget the BUILD script and README files.


ABCDEFGHIJKLMNOPQ
17


Assignment 3: Standard I/O Library
Original author: Munehiro Fukuda

Revisions 2019: Morris Bernstein

As we have seen in Lab 3, the operating system calls open, close, read, write, llseek, etc. provide an effective interface to the filesystem, but have significant limitations. Performance and convenience can be dramatically improved using a higher-level userland library that provides buffering and data-formatting. Furthermore, programs that use the language-defined standard library are more likely to be portable across operating systems.

The standard I/O library of the C language is available to any C or C++ program that includes the stdio.h (cstdio in C++) header file. Since C predates the object-oriented paradigm, the FILE* object is passed in as the first argument to the various functions that implement file operations, but it is fundamentally an operation on an object.

For this assignment, you will implement a class-based version of the C standard I/O library. The constructor will open the file, and the destructor will close the file.

Since constructors and destructors don't return values, we have to alter the semantics slightly: if an error occurs, throw an exception.

Implement the following methods using only the underlying system calls. See the corresponding man pages. Note that the file argument is implicit in the method call, so we must alter the function signature slightly.
ferror
feof
fflush
fputc
fgetc
fgets
fputs
fseek
Do not use the C++ standard template library, C++ strings library, C standard I/O library or C standard strings functions. You may use malloc to allocate the buffer.

Behavior should be predictable even for files opened in read/write mode. For example, if you read ABC from the file, write XYZ, and then read GHI, the file should end up containing ABCXYZGHI regardless of the buffering mode. Similarly, writing ABCDEFGHI, repositioning the file pointer to the beginning of the file ("rewinding") and writing XYZ should leave XYZDEFGHI in the file regardless of the buffering mode.

Your test program should verify that writing to a read-only file is an error; reading from a write-only file is an error; and that the the code correctly handles the switch between reading and writing in read/write mode.

Your implementation need not worry about thread-safety.

For the purposes of the assignment you only need to implement the default FULL_BUFFER mode. setvbuf is unsupported.

"a" and "a+" modes have complicated semantics and need not be implemented.

You may crash the program if any unsupported feature is called. See undefined behavior.

An application using your library should #include "file.h" and link with file.o (produced by compiling file.cc with the -c flag. Simulate this by putting your implementation and test program in separate directories (use the -I flag when compiling your test program).

Repeat the benchmarking of Lab 3 for your implementation. This means you will be creating two separate executable programs that use your I/O library.

Skeletons have been provided: file-skel.h and file-skel.cc. You may also reuse or cannibalize any of the work that you did for Lab 3.

For reference, a simplified version of fprintf has been provided in the skeleton code.

Don't forget the BUILD script and README files.


ABCDEFGHIJKLMNOPQ
18


Assignment 3: Standard I/O Library
Original author: Munehiro Fukuda

Revisions 2019: Morris Bernstein

As we have seen in Lab 3, the operating system calls open, close, read, write, llseek, etc. provide an effective interface to the filesystem, but have significant limitations. Performance and convenience can be dramatically improved using a higher-level userland library that provides buffering and data-formatting. Furthermore, programs that use the language-defined standard library are more likely to be portable across operating systems.

The standard I/O library of the C language is available to any C or C++ program that includes the stdio.h (cstdio in C++) header file. Since C predates the object-oriented paradigm, the FILE* object is passed in as the first argument to the various functions that implement file operations, but it is fundamentally an operation on an object.

For this assignment, you will implement a class-based version of the C standard I/O library. The constructor will open the file, and the destructor will close the file.

Since constructors and destructors don't return values, we have to alter the semantics slightly: if an error occurs, throw an exception.

Implement the following methods using only the underlying system calls. See the corresponding man pages. Note that the file argument is implicit in the method call, so we must alter the function signature slightly.
ferror
feof
fflush
fputc
fgetc
fgets
fputs
fseek
Do not use the C++ standard template library, C++ strings library, C standard I/O library or C standard strings functions. You may use malloc to allocate the buffer.

Behavior should be predictable even for files opened in read/write mode. For example, if you read ABC from the file, write XYZ, and then read GHI, the file should end up containing ABCXYZGHI regardless of the buffering mode. Similarly, writing ABCDEFGHI, repositioning the file pointer to the beginning of the file ("rewinding") and writing XYZ should leave XYZDEFGHI in the file regardless of the buffering mode.

Your test program should verify that writing to a read-only file is an error; reading from a write-only file is an error; and that the the code correctly handles the switch between reading and writing in read/write mode.

Your implementation need not worry about thread-safety.

For the purposes of the assignment you only need to implement the default FULL_BUFFER mode. setvbuf is unsupported.

"a" and "a+" modes have complicated semantics and need not be implemented.

You may crash the program if any unsupported feature is called. See undefined behavior.

An application using your library should #include "file.h" and link with file.o (produced by compiling file.cc with the -c flag. Simulate this by putting your implementation and test program in separate directories (use the -I flag when compiling your test program).

Repeat the benchmarking of Lab 3 for your implementation. This means you will be creating two separate executable programs that use your I/O library.

Skeletons have been provided: file-skel.h and file-skel.cc. You may also reuse or cannibalize any of the work that you did for Lab 3.

For reference, a simplified version of fprintf has been provided in the skeleton code.

Don't forget the BUILD script and README files.


ABCDEFGHIJKLMNOPQ
19


Assignment 3: Standard I/O Library
Original author: Munehiro Fukuda

Revisions 2019: Morris Bernstein

As we have seen in Lab 3, the operating system calls open, close, read, write, llseek, etc. provide an effective interface to the filesystem, but have significant limitations. Performance and convenience can be dramatically improved using a higher-level userland library that provides buffering and data-formatting. Furthermore, programs that use the language-defined standard library are more likely to be portable across operating systems.

The standard I/O library of the C language is available to any C or C++ program that includes the stdio.h (cstdio in C++) header file. Since C predates the object-oriented paradigm, the FILE* object is passed in as the first argument to the various functions that implement file operations, but it is fundamentally an operation on an object.

For this assignment, you will implement a class-based version of the C standard I/O library. The constructor will open the file, and the destructor will close the file.

Since constructors and destructors don't return values, we have to alter the semantics slightly: if an error occurs, throw an exception.

Implement the following methods using only the underlying system calls. See the corresponding man pages. Note that the file argument is implicit in the method call, so we must alter the function signature slightly.
ferror
feof
fflush
fputc
fgetc
fgets
fputs
fseek
Do not use the C++ standard template library, C++ strings library, C standard I/O library or C standard strings functions. You may use malloc to allocate the buffer.

Behavior should be predictable even for files opened in read/write mode. For example, if you read ABC from the file, write XYZ, and then read GHI, the file should end up containing ABCXYZGHI regardless of the buffering mode. Similarly, writing ABCDEFGHI, repositioning the file pointer to the beginning of the file ("rewinding") and writing XYZ should leave XYZDEFGHI in the file regardless of the buffering mode.

Your test program should verify that writing to a read-only file is an error; reading from a write-only file is an error; and that the the code correctly handles the switch between reading and writing in read/write mode.

Your implementation need not worry about thread-safety.

For the purposes of the assignment you only need to implement the default FULL_BUFFER mode. setvbuf is unsupported.

"a" and "a+" modes have complicated semantics and need not be implemented.

You may crash the program if any unsupported feature is called. See undefined behavior.

An application using your library should #include "file.h" and link with file.o (produced by compiling file.cc with the -c flag. Simulate this by putting your implementation and test program in separate directories (use the -I flag when compiling your test program).

Repeat the benchmarking of Lab 3 for your implementation. This means you will be creating two separate executable programs that use your I/O library.

Skeletons have been provided: file-skel.h and file-skel.cc. You may also reuse or cannibalize any of the work that you did for Lab 3.

For reference, a simplified version of fprintf has been provided in the skeleton code.

Don't forget the BUILD script and README files.


ABCDEFGHIJKLMNOPQ
20


Assignment 3: Standard I/O Library
Original author: Munehiro Fukuda

Revisions 2019: Morris Bernstein

As we have seen in Lab 3, the operating system calls open, close, read, write, llseek, etc. provide an effective interface to the filesystem, but have significant limitations. Performance and convenience can be dramatically improved using a higher-level userland library that provides buffering and data-formatting. Furthermore, programs that use the language-defined standard library are more likely to be portable across operating systems.

The standard I/O library of the C language is available to any C or C++ program that includes the stdio.h (cstdio in C++) header file. Since C predates the object-oriented paradigm, the FILE* object is passed in as the first argument to the various functions that implement file operations, but it is fundamentally an operation on an object.

For this assignment, you will implement a class-based version of the C standard I/O library. The constructor will open the file, and the destructor will close the file.

Since constructors and destructors don't return values, we have to alter the semantics slightly: if an error occurs, throw a
 ********************************************* 



 ******* The 12 time fread and read 12288 bits ********
n exception.

Implement the following methods using only the underlying system calls. See the corresponding man pages. Note that the file argument is implicit in the method call, so we must alter the function signature slightly.
ferror
feof
fflush
fputc
fgetc
fgets
fputs
fseek
Do not use the C++ standard template library, C++ strings library, C standard I/O library or C standard strings functions. You may use malloc to allocate the buffer.

Behavior should be predictable even for files opened in read/write mode. For example, if you read ABC from the file, write XYZ, and then read GHI, the file should end up containing ABCXYZGHI regardless of the buffering mode. Similarly, writing ABCDEFGHI, repositioning the file pointer to the beginning of the file ("rewinding") and writing XYZ should leave XYZDEFGHI in the file regardless of the buffering mode.

Your test program should verify that writing to a read-only file is an error; reading from a write-only file is an error; and that the the code correctly handles the switch between reading and writing in read/write mode.

Your implementation need not worry about thread-safety.

For the purposes of the assignment you only need to implement the default FULL_BUFFER mode. setvbuf is unsupported.

"a" and "a+" modes have complicated semantics and need not be implemented.

You may crash the program if any unsupported feature is called. See undefined behavior.

An application using your library should #include "file.h" and link with file.o (produced by compiling file.cc with the -c flag. Simulate this by putting your implementation and test program in separate directories (use the -I flag when compiling your test program).

Repeat the benchmarking of Lab 3 for your implementation. This means you will be creating two separate executable programs that use your I/O library.

Skeletons have been provided: file-skel.h and file-skel.cc. You may also reuse or cannibalize any of the work that you did for Lab 3.

For reference, a simplified version of fprintf has been provided in the skeleton code.

Don't forget the BUILD script and README files.


ABCDEFGHIJKLMNOPQ
21


Assignment 3: Standard I/O Library
Original author: Munehiro Fukuda

Revisions 2019: Morris Bernstein

As we have seen in Lab 3, the operating system calls open, close, read, write, llseek, etc. provide an effective interface to the filesystem, but have significant limitations. Performance and convenience can be dramatically improved using a higher-level userland library that provides buffering and data-formatting. Furthermore, programs that use the language-defined standard library are more likely to be portable across operating systems.

The standard I/O library of the C language is available to any C or C++ program that includes the stdio.h (cstdio in C++) header file. Since C predates the object-oriented paradigm, the FILE* object is passed in as the first argument to the various functions that implement file operations, but it is fundamentally an operation on an object.

For this assignment, you will implement a class-based version of the C standard I/O library. The constructor will open the file, and the destructor will close the file.

Since constructors and destructors don't return values, we have to alter the semantics slightly: if an error occurs, throw an exception.

Implement the following methods using only the underlying system calls. See the corresponding man pages. Note that the file argument is implicit in the method call, so we must alter the function signature slightly.
ferror
feof
fflush
fputc
fgetc
fgets
fputs
fseek
Do not use the C++ standard template library, C++ strings library, C standard I/O library or C standard strings functions. You may use malloc to allocate the buffer.

Behavior should be predictable even for files opened in read/write mode. For example, if you read ABC from the file, write XYZ, and then read GHI, the file should end up containing ABCXYZGHI regardless of the buffering mode. Similarly, writing ABCDEFGHI, repositioning the file pointer to the beginning of the file ("rewinding") and writing XYZ should leave XYZDEFGHI in the file regardless of the buffering mode.

Your test program should verify that writing to a read-only file is an error; reading from a write-only file is an error; and that the the code correctly handles the switch between reading and writing in read/write mode.

Your implementation need not worry about thread-safety.

For the purposes of the assignment you only need to implement the default FULL_BUFFER mode. setvbuf is unsupported.

"a" and "a+" modes have complicated semantics and need not be implemented.

You may crash the program if any unsupported feature is called. See undefined behavior.

An application using your library should #include "file.h" and link with file.o (produced by compiling file.cc with the -c flag. Simulate this by putting your implementation and test program in separate directories (use the -I flag when compiling your test program).

Repeat the benchmarking of Lab 3 for your implementation. This means you will be creating two separate executable programs that use your I/O library.

Skeletons have been provided: file-skel.h and file-skel.cc. You may also reuse or cannibalize any of the work that you did for Lab 3.

For reference, a simplified version of fprintf has been provided in the skeleton code.

Don't forget the BUILD script and README files.


ABCDEFGHIJKLMNOPQ
22


Assignment 3: Standard I/O Library
Original author: Munehiro Fukuda

Revisions 2019: Morris Bernstein

As we have seen in Lab 3, the operating system calls open, close, read, write, llseek, etc. provide an effective interface to the filesystem, but have significant limitations. Performance and convenience can be dramatically improved using a higher-level userland library that provides buffering and data-formatting. Furthermore, programs that use the language-defined standard library are more likely to be portable across operating systems.

The standard I/O library of the C language is available to any C or C++ program that includes the stdio.h (cstdio in C++) header file. Since C predates the object-oriented paradigm, the FILE* object is passed in as the first argument to the various functions that implement file operations, but it is fundamentally an operation on an object.

For this assignment, you will implement a class-based version of the C standard I/O library. The constructor will open the file, and the destructor will close the file.

Since constructors and destructors don't return values, we have to alter the semantics slightly: if an error occurs, throw an exception.

Implement the following methods using only the underlying system calls. See the corresponding man pages. Note that the file argument is implicit in the method call, so we must alter the function signature slightly.
ferror
feof
fflush
fputc
fgetc
fgets
fputs
fseek
Do not use the C++ standard template library, C++ strings library, C standard I/O library or C standard strings functions. You may use malloc to allocate the buffer.

Behavior should be predictable even for files opened in read/write mode. For example, if you read ABC from the file, write XYZ, and then read GHI, the file should end up containing ABCXYZGHI regardless of the buffering mode. Similarly, writing ABCDEFGHI, repositioning the file pointer to the beginning of the file ("rewinding") and writing XYZ should leave XYZDEFGHI in the file regardless of the buffering mode.

Your test program should verify that writing to a read-only file is an error; reading from a write-only file is an error; and that the the code correctly handles the switch between reading and writing in read/write mode.

Your implementation need not worry about thread-safety.

For the purposes of the assignment you only need to implement the default FULL_BUFFER mode. setvbuf is unsupported.

"a" and "a+" modes have complicated semantics and need not be implemented.

You may crash the program if any unsupported feature is called. See undefined behavior.

An application using your library should #include "file.h" and link with file.o (produced by compiling file.cc with the -c flag. Simulate this by putting your implementation and test program in separate directories (use the -I flag when compiling your test program).

Repeat the benchmarking of Lab 3 for your implementation. This means you will be creating two separate executable programs that use your I/O library.

Skeletons have been provided: file-skel.h and file-skel.cc. You may also reuse or cannibalize any of the work that you did for Lab 3.

For reference, a simplified version of fprintf has been provided in the skeleton code.

Don't forget the BUILD script and README files.


ABCDEFGHIJKLMNOPQ
23


Assignment 3: Standard I/O Library
Original author: Munehiro Fukuda

Revisions 2019: Morris Bernstein

As we have seen in Lab 3, the operating system calls open, close, read, write, llseek, etc. provide an effective interface to the filesystem, but have significant limitations. Performance and convenience can be dramatically improved using a higher-level userland library that provides buffering and data-formatting. Furthermore, programs that use the language-defined standard library are more likely to be portable across operating systems.

The standard I/O library of the C language is available to any C or C++ program that includes the stdio.h (cstdio in C++) header file. Since C predates the object-oriented paradigm, the FILE* object is passed in as the first argument to the various functions that implement file operations, but it is fundamentally an operation on an object.

For this assignment, you will implement a class-based version of the C standard I/O library. The constructor will open the file, and the destructor will close the file.

Since constructors and destructors don't return values, we have to alter the semantics slightly: if an error occurs, throw an exception.

Implement the following methods using only the underlying system calls. See the corresponding man pages. Note that the file argument is implicit in the method call, so we must alter the function signature slightly.
ferror
feof
fflush
fputc
fgetc
fgets
fputs
fseek
Do not use the C++ standard template library, C++ strings library, C standard I/O library or C standard strings functions. You may use malloc to allocate the buffer.

Behavior should be predictable even for files opened in read/write mode. For example, if you read ABC from the file, write XYZ, and then read GHI, the file should end up containing ABCXYZGHI regardless of the buffering mode. Similarly, writing ABCDEFGHI, repositioning the file pointer to the beginning of the file ("rewinding") and writing XYZ should leave XYZDEFGHI in the file regardless of the buffering mode.

Your test program should verify that writing to a read-only file is an error; reading from a write-only file is an error; and that the the code correctly handles the switch between reading and writing in read/write mode.

Your implementation need not worry about thread-safety.

For the purposes of the assignment you only need to implement the default FULL_BUFFER mode. setvbuf is unsupported.

"a" and "a+" modes have complicated semantics and need not be implemented.

You may crash the program if any unsupported feature is called. See undefined behavior.

An application using your library should #include "file.h" and link with file.o (produced by compiling file.cc with the -c flag. Simulate this by putting your implementation and test program in separate directories (use the -I flag when compiling your test program).

Repeat the benchmarking of Lab 3 for your implementation. This means you will be creating two separate executable programs that use your I/O library.

Skeletons have been provided: file-skel.h and file-skel.cc. You may also reuse or cannibalize any of the work that you did for Lab 3.

For reference, a simplified version of fprintf has been provided in the skeleton code.

Don't forget the BUILD script and README files.


ABCDEFGHIJKLMNOPQ
24


Assignment 3: Standard I/O Library
Original author: Munehiro Fukuda

Revisions 2019: Morris Bernstein

As we have seen in Lab 3, the operating system calls open, close, read, write, llseek, etc. 
 ********************************************* 



 ******* The 13 time fread and read 13312 bits ********
provide an effective interface to the filesystem, but have significant limitations. Performance and convenience can be dramatically improved using a higher-level userland library that provides buffering and data-formatting. Furthermore, programs that use the language-defined standard library are more likely to be portable across operating systems.

The standard I/O library of the C language is available to any C or C++ program that includes the stdio.h (cstdio in C++) header file. Since C predates the object-oriented paradigm, the FILE* object is passed in as the first argument to the various functions that implement file operations, but it is fundamentally an operation on an object.

For this assignment, you will implement a class-based version of the C standard I/O library. The constructor will open the file, and the destructor will close the file.

Since constructors and destructors don't return values, we have to alter the semantics slightly: if an error occurs, throw an exception.

Implement the following methods using only the underlying system calls. See the corresponding man pages. Note that the file argument is implicit in the method call, so we must alter the function signature slightly.
ferror
feof
fflush
fputc
fgetc
fgets
fputs
fseek
Do not use the C++ standard template library, C++ strings library, C standard I/O library or C standard strings functions. You may use malloc to allocate the buffer.

Behavior should be predictable even for files opened in read/write mode. For example, if you read ABC from the file, write XYZ, and then read GHI, the file should end up containing ABCXYZGHI regardless of the buffering mode. Similarly, writing ABCDEFGHI, repositioning the file pointer to the beginning of the file ("rewinding") and writing XYZ should leave XYZDEFGHI in the file regardless of the buffering mode.

Your test program should verify that writing to a read-only file is an error; reading from a write-only file is an error; and that the the code correctly handles the switch between reading and writing in read/write mode.

Your implementation need not worry about thread-safety.

For the purposes of the assignment you only need to implement the default FULL_BUFFER mode. setvbuf is unsupported.

"a" and "a+" modes have complicated semantics and need not be implemented.

You may crash the program if any unsupported feature is called. See undefined behavior.

An application using your library should #include "file.h" and link with file.o (produced by compiling file.cc with the -c flag. Simulate this by putting your implementation and test program in separate directories (use the -I flag when compiling your test program).

Repeat the benchmarking of Lab 3 for your implementation. This means you will be creating two separate executable programs that use your I/O library.

Skeletons have been provided: file-skel.h and file-skel.cc. You may also reuse or cannibalize any of the work that you did for Lab 3.

For reference, a simplified version of fprintf has been provided in the skeleton code.

Don't forget the BUILD script and README files.


ABCDEFGHIJKLMNOPQ
25


Assignment 3: Standard I/O Library
Original author: Munehiro Fukuda

Revisions 2019: Morris Bernstein

As we have seen in Lab 3, the operating system calls open, close, read, write, llseek, etc. provide an effective interface to the filesystem, but have significant limitations. Performance and convenience can be dramatically improved using a higher-level userland library that provides buffering and data-formatting. Furthermore, programs that use the language-defined standard library are more likely to be portable across operating systems.

The standard I/O library of the C language is available to any C or C++ program that includes the stdio.h (cstdio in C++) header file. Since C predates the object-oriented paradigm, the FILE* object is passed in as the first argument to the various functions that implement file operations, but it is fundamentally an operation on an object.

For this assignment, you will implement a class-based version of the C standard I/O library. The constructor will open the file, and the destructor will close the file.

Since constructors and destructors don't return values, we have to alter the semantics slightly: if an error occurs, throw an exception.

Implement the following methods using only the underlying system calls. See the corresponding man pages. Note that the file argument is implicit in the method call, so we must alter the function signature slightly.
ferror
feof
fflush
fputc
fgetc
fgets
fputs
fseek
Do not use the C++ standard template library, C++ strings library, C standard I/O library or C standard strings functions. You may use malloc to allocate the buffer.

Behavior should be predictable even for files opened in read/write mode. For example, if you read ABC from the file, write XYZ, and then read GHI, the file should end up containing ABCXYZGHI regardless of the buffering mode. Similarly, writing ABCDEFGHI, repositioning the file pointer to the beginning of the file ("rewinding") and writing XYZ should leave XYZDEFGHI in the file regardless of the buffering mode.

Your test program should verify that writing to a read-only file is an error; reading from a write-only file is an error; and that the the code correctly handles the switch between reading and writing in read/write mode.

Your implementation need not worry about thread-safety.

For the purposes of the assignment you only need to implement the default FULL_BUFFER mode. setvbuf is unsupported.

"a" and "a+" modes have complicated semantics and need not be implemented.

You may crash the program if any unsupported feature is called. See undefined behavior.

An application using your library should #include "file.h" and link with file.o (produced by compiling file.cc with the -c flag. Simulate this by putting your implementation and test program in separate directories (use the -I flag when compiling your test program).

Repeat the benchmarking of Lab 3 for your implementation. This means you will be creating two separate executable programs that use your I/O library.

Skeletons have been provided: file-skel.h and file-skel.cc. You may also reuse or cannibalize any of the work that you did for Lab 3.

For reference, a simplified version of fprintf has been provided in the skeleton code.

Don't forget the BUILD script and README files.


ABCDEFGHIJKLMNOPQ
26


Assignment 3: Standard I/O Library
Original author: Munehiro Fukuda

Revisions 2019: Morris Bernstein

As we have seen in Lab 3, the operating system calls open, close, read, write, llseek, etc. provide an effective interface to the filesystem, but have significant limitations. Performance and convenience can be dramatically improved using a higher-level userland library that provides buffering and data-formatting. Furthermore, programs that use the language-defined standard library are more likely to be portable across operating systems.

The standard I/O library of the C language is available to any C or C++ program that includes the stdio.h (cstdio in C++) header file. Since C predates the object-oriented paradigm, the FILE* object is passed in as the first argument to the various functions that implement file operations, but it is fundamentally an operation on an object.

For this assignment, you will implement a class-based version of the C standard I/O library. The constructor will open the file, and the destructor will close the file.

Since constructors and destructors don't return values, we have to alter the semantics slightly: if an error occurs, throw an exception.

Implement the following methods using only the underlying system calls. See the corresponding man pages. Note that the file argument is implicit in the method call, so we must alter the function signature slightly.
ferror
feof
fflush
fputc
fgetc
fgets
fputs
fseek
Do not use the C++ standard template library, C++ strings library, C standard I/O library or C standard strings functions. You may use malloc to allocate the buffer.

Behavior should be predictable even for files opened in read/write mode. For example, if you read ABC from the file, write XYZ, and then read GHI, the file should end up containing ABCXYZGHI regardless of the buffering mode. Similarly, writing ABCDEFGHI, repositioning the file pointer to the beginning of the file ("rewinding") and writing XYZ should leave XYZDEFGHI in the file regardless of the buffering mode.

Your test program should verify that writing to a read-only file is an error; reading from a write-only file is an error; and that the the code correctly handles the switch between reading and writing in read/write mode.

Your implementation need not worry about thread-safety.

For the purposes of the assignment you only need to implement the default FULL_BUFFER mode. setvbuf is unsupported.

"a" and "a+" modes have complicated semantics and need not be implemented.

You may crash the program if any unsupported feature is called. See undefined behavior.

An application using your library should #include "file.h" and link with file.o (produced by compiling file.cc with the -c flag. Simulate this by putting your implementation and test program in separate directories (use the -I flag when compiling your test program).

Repeat the benchmarking of Lab 3 for your implementation. This means you will be creating two separate executable programs that use your I/O library.

Skeletons have been provided: file-skel.h and file-skel.cc. You may also reuse or cannibalize any of the work that you did for Lab 3.

For reference, a simplified version of fprintf has been provided in the skeleton code.

Don't forget the BUILD script and README files.


ABCDEFGHIJKLMNOPQ
27


Assignment 3: Standard I/O Library
Original author: Munehiro Fukuda

Revisions 2019: Morris Bernstein

As we have seen in Lab 3, the operating system calls open, close, read, write, llseek, etc. provide an effective interface to the filesystem, but have significant limitations. Performance and convenience can be dramatically improved using a higher-level userland library that provides buffering and data-formatting. Furthermore, programs that use the language-defined standard library are more likely to be portable across operating systems.

The standard I/O library of the C language is available to any C or C++ program that includes the stdio.h (cstdio in C++) header file. Since C predates the object-oriented paradigm, the FILE* object is passed in as the first argument to the various functions that implement file operations, but it is fundamentally an operation on an object.

For this assignment, you will implement a class-based version of the C standard I/O library. The constructor will open the file, and the destructor will close the file.

Since constructors and destructors don't return values, we have to alter the semantics slightly: if an error occurs, throw an exception.

Implement the following methods using only the underlying system calls. See the corresponding man pages. Note that the file argument is implicit in the method call, so we must alter the function signature slightly.
ferror
feof
fflush
fputc
fgetc
fgets
fputs
fseek
Do not use the C++ standard template library, C++ strings library, C standard I/O library or C standard strings functions. You may use malloc to allocate the buffer.

Behavior should be predictable even for files opened in read/write mode. For example, if you read ABC from the file, write XYZ, and then read GHI, the file should end up containing ABCXYZGHI regardless of the buffering mode. Similarly, writing ABCDEFGHI, repositioning the file pointer to the beginning of the file ("rewinding") and writing XYZ should leave XYZDEFGHI in the file regardless of the buffering mode.

Your test program should verify that writing to a read-only file is an error; reading from a write-only file is an error; and that the the code correctly handles the switch between reading and writing in read/write mode.

Your implementation need not worry about thread-safety.

For the purposes of the assignment you only need to implement the default FULL_BUFFER mode. setvbuf is unsupported.

"a" and "a+" modes have complicated semantics and need not be implemented.

You may crash the program if any unsupported feature is called. See undefined behavior.

An application using your library should #include "file.h" and link with file.o (produced by compiling file.cc with the -c flag. Simulate this by putting your implementation and test program in separate directories (use the -I flag when compiling your test program).

Repeat the benchmarking of Lab 3 for your implementation. This means you will be creating two separate executable programs that use your I/O library.

Skeletons have been provided: file-skel.h and file-skel.cc. You may also reuse or cannibalize any of the work that you did for Lab 3.

For reference, a simplified version of fprintf has been provided in the skeleton code.

Don't forget the BUILD script and README files.


ABCDEFGHIJKLMNOPQ
28


Assignment 3: Standard I/O Library
Original author: Munehiro Fukuda

Revisions 2019: Morris Bernstein

As we have seen in Lab 3, the operating system calls open, close, read, write, llseek, etc. provide an effective interface to th
 ********************************************* 



 ******* The 14 time fread and read 14336 bits ********
e filesystem, but have significant limitations. Performance and convenience can be dramatically improved using a higher-level userland library that provides buffering and data-formatting. Furthermore, programs that use the language-defined standard library are more likely to be portable across operating systems.

The standard I/O library of the C language is available to any C or C++ program that includes the stdio.h (cstdio in C++) header file. Since C predates the object-oriented paradigm, the FILE* object is passed in as the first argument to the various functions that implement file operations, but it is fundamentally an operation on an object.

For this assignment, you will implement a class-based version of the C standard I/O library. The constructor will open the file, and the destructor will close the file.

Since constructors and destructors don't return values, we have to alter the semantics slightly: if an error occurs, throw an exception.

Implement the following methods using only the underlying system calls. See the corresponding man pages. Note that the file argument is implicit in the method call, so we must alter the function signature slightly.
ferror
feof
fflush
fputc
fgetc
fgets
fputs
fseek
Do not use the C++ standard template library, C++ strings library, C standard I/O library or C standard strings functions. You may use malloc to allocate the buffer.

Behavior should be predictable even for files opened in read/write mode. For example, if you read ABC from the file, write XYZ, and then read GHI, the file should end up containing ABCXYZGHI regardless of the buffering mode. Similarly, writing ABCDEFGHI, repositioning the file pointer to the beginning of the file ("rewinding") and writing XYZ should leave XYZDEFGHI in the file regardless of the buffering mode.

Your test program should verify that writing to a read-only file is an error; reading from a write-only file is an error; and that the the code correctly handles the switch between reading and writing in read/write mode.

Your implementation need not worry about thread-safety.

For the purposes of the assignment you only need to implement the default FULL_BUFFER mode. setvbuf is unsupported.

"a" and "a+" modes have complicated semantics and need not be implemented.

You may crash the program if any unsupported feature is called. See undefined behavior.

An application using your library should #include "file.h" and link with file.o (produced by compiling file.cc with the -c flag. Simulate this by putting your implementation and test program in separate directories (use the -I flag when compiling your test program).

Repeat the benchmarking of Lab 3 for your implementation. This means you will be creating two separate executable programs that use your I/O library.

Skeletons have been provided: file-skel.h and file-skel.cc. You may also reuse or cannibalize any of the work that you did for Lab 3.

For reference, a simplified version of fprintf has been provided in the skeleton code.

Don't forget the BUILD script and README files.


ABCDEFGHIJKLMNOPQ
29


Assignment 3: Standard I/O Library
Original author: Munehiro Fukuda

Revisions 2019: Morris Bernstein

As we have seen in Lab 3, the operating system calls open, close, read, write, llseek, etc. provide an effective interface to the filesystem, but have significant limitations. Performance and convenience can be dramatically improved using a higher-level userland library that provides buffering and data-formatting. Furthermore, programs that use the language-defined standard library are more likely to be portable across operating systems.

The standard I/O library of the C language is available to any C or C++ program that includes the stdio.h (cstdio in C++) header file. Since C predates the object-oriented paradigm, the FILE* object is passed in as the first argument to the various functions that implement file operations, but it is fundamentally an operation on an object.

For this assignment, you will implement a class-based version of the C standard I/O library. The constructor will open the file, and the destructor will close the file.

Since constructors and destructors don't return values, we have to alter the semantics slightly: if an error occurs, throw an exception.

Implement the following methods using only the underlying system calls. See the corresponding man pages. Note that the file argument is implicit in the method call, so we must alter the function signature slightly.
ferror
feof
fflush
fputc
fgetc
fgets
fputs
fseek
Do not use the C++ standard template library, C++ strings library, C standard I/O library or C standard strings functions. You may use malloc to allocate the buffer.

Behavior should be predictable even for files opened in read/write mode. For example, if you read ABC from the file, write XYZ, and then read GHI, the file should end up containing ABCXYZGHI regardless of the buffering mode. Similarly, writing ABCDEFGHI, repositioning the file pointer to the beginning of the file ("rewinding") and writing XYZ should leave XYZDEFGHI in the file regardless of the buffering mode.

Your test program should verify that writing to a read-only file is an error; reading from a write-only file is an error; and that the the code correctly handles the switch between reading and writing in read/write mode.

Your implementation need not worry about thread-safety.

For the purposes of the assignment you only need to implement the default FULL_BUFFER mode. setvbuf is unsupported.

"a" and "a+" modes have complicated semantics and need not be implemented.

You may crash the program if any unsupported feature is called. See undefined behavior.

An application using your library should #include "file.h" and link with file.o (produced by compiling file.cc with the -c flag. Simulate this by putting your implementation and test program in separate directories (use the -I flag when compiling your test program).

Repeat the benchmarking of Lab 3 for your implementation. This means you will be creating two separate executable programs that use your I/O library.

Skeletons have been provided: file-skel.h and file-skel.cc. You may also reuse or cannibalize any of the work that you did for Lab 3.

For reference, a simplified version of fprintf has been provided in the skeleton code.

Don't forget the BUILD script and README files.


ABCDEFGHIJKLMNOPQ
30


Assignment 3: Standard I/O Library
Original author: Munehiro Fukuda

Revisions 2019: Morris Bernstein

As we have seen in Lab 3, the operating system calls open, close, read, write, llseek, etc. provide an effective interface to the filesystem, but have significant limitations. Performance and convenience can be dramatically improved using a higher-level userland library that provides buffering and data-formatting. Furthermore, programs that use the language-defined standard library are more likely to be portable across operating systems.

The standard I/O library of the C language is available to any C or C++ program that includes the stdio.h (cstdio in C++) header file. Since C predates the object-oriented paradigm, the FILE* object is passed in as the first argument to the various functions that implement file operations, but it is fundamentally an operation on an object.

For this assignment, you will implement a class-based version of the C standard I/O library. The constructor will open the file, and the destructor will close the file.

Since constructors and destructors don't return values, we have to alter the semantics slightly: if an error occurs, throw an exception.

Implement the following methods using only the underlying system calls. See the corresponding man pages. Note that the file argument is implicit in the method call, so we must alter the function signature slightly.
ferror
feof
fflush
fputc
fgetc
fgets
fputs
fseek
Do not use the C++ standard template library, C++ strings library, C standard I/O library or C standard strings functions. You may use malloc to allocate the buffer.

Behavior should be predictable even for files opened in read/write mode. For example, if you read ABC from the file, write XYZ, and then read GHI, the file should end up containing ABCXYZGHI regardless of the buffering mode. Similarly, writing ABCDEFGHI, repositioning the file pointer to the beginning of the file ("rewinding") and writing XYZ should leave XYZDEFGHI in the file regardless of the buffering mode.

Your test program should verify that writing to a read-only file is an error; reading from a write-only file is an error; and that the the code correctly handles the switch between reading and writing in read/write mode.

Your implementation need not worry about thread-safety.

For the purposes of the assignment you only need to implement the default FULL_BUFFER mode. setvbuf is unsupported.

"a" and "a+" modes have complicated semantics and need not be implemented.

You may crash the program if any unsupported feature is called. See undefined behavior.

An application using your library should #include "file.h" and link with file.o (produced by compiling file.cc with the -c flag. Simulate this by putting your implementation and test program in separate directories (use the -I flag when compiling your test program).

Repeat the benchmarking of Lab 3 for your implementation. This means you will be creating two separate executable programs that use your I/O library.

Skeletons have been provided: file-skel.h and file-skel.cc. You may also reuse or cannibalize any of the work that you did for Lab 3.

For reference, a simplified version of fprintf has been provided in the skeleton code.

Don't forget the BUILD script and README files.



ABCDEFGHIJKLMNOPQ
31


Assignment 3: Standard I/O Library
Original author: Munehiro Fukuda

Revisions 2019: Morris Bernstein

As we have seen in Lab 3, the operating system calls open, close, read, write, llseek, etc. provide an effective interface to the filesystem, but have significant limitations. Performance and convenience can be dramatically improved using a higher-level userland library that provides buffering and data-formatting. Furthermore, programs that use the language-defined standard library are more likely to be portable across operating systems.

The standard I/O library of the C language is available to any C or C++ program that includes the stdio.h (cstdio in C++) header file. Since C predates the object-oriented paradigm, the FILE* object is passed in as the first argument to the various functions that implement file operations, but it is fundamentally an operation on an object.

For this assignment, you will implement a class-based version of the C standard I/O library. The constructor will open the file, and the destructor will close the file.

Since constructors and destructors don't return values, we have to alter the semantics slightly: if an error occurs, throw an exception.

Implement the following methods using only the underlying system calls. See the corresponding man pages. Note that the file argument is implicit in the method call, so we must alter the function signature slightly.
ferror
feof
fflush
fputc
fgetc
fgets
fputs
fseek
Do not use the C++ standard template library, C++ strings library, C standard I/O library or C standard strings functions. You may use malloc to allocate the buffer.

Behavior should be predictable even for files opened in read/write mode. For example, if you read ABC from the file, write XYZ, and then read GHI, the file should end up containing ABCXYZGHI regardless of the buffering mode. Similarly, writing ABCDEFGHI, repositioning the file pointer to the beginning of the file ("rewinding") and writing XYZ should leave XYZDEFGHI in the file regardless of the buffering mode.

Your test program should verify that writing to a read-only file is an error; reading from a write-only file is an error; and that the the code correctly handles the switch between reading and writing in read/write mode.

Your implementation need not worry about thread-safety.

For the purposes of the assignment you only need to implement the default FULL_BUFFER mode. setvbuf is unsupported.

"a" and "a+" modes have complicated semantics and need not be implemented.

You may crash the program if any unsupported feature is called. See undefined behavior.

An application using your library should #include "file.h" and link with file.o (produced by compiling file.cc with the -c flag. Simulate this by putting your implementation and test program in separate directories (use the -I flag when compiling your test program).

Repeat the benchmarking of Lab 3 for your implementation. This means you will be creating two separate executable programs that use your I/O library.

Skeletons have been provided: file-skel.h and file-skel.cc. You may also reuse or cannibalize any of the work that you did for Lab 3.

For reference, a simplified version of fprintf has been provided in the skeleton code.

Don't forget the BUILD script and README files.


ABCDEFGHIJKLMNOPQ
32


Assignment 3: Standard I/O Library
Original author: Munehiro Fukuda

Revisions 2019: Morris Bernstein

As we have seen in Lab 3, the operating system calls open, close, read, write, llseek, etc. provide an effective interface to the filesystem, but have significant limitations. Performance and convenience can be dramatically improved using a higher-level userland library that provides buffering and data-formatting. Furthermore, programs that use the language-defined standard library are more likely to be portable across operating systems.

The standard I/O library of the C language is available to any C or C++ program that includes the stdio.h (cstdio in C++) header file. Since C predates the object-oriented paradigm, the FILE* object is passed in as the first argument to the various functions that implement file operations, but it is fundamentally an operation on an object.

For this assignment, you will implement a class-based version of the C standard I/O library. The constructor will open the file, and the destructor will close the file.

Since constructors and destructors don't return values, we have to alter the semantics slightly: if an error occurs, throw an exception.

Implement the following methods using only the underlying system calls. See the corresponding
 ********************************************* 



 ******* The 15 time fread and read 15360 bits ********
 man pages. Note that the file argument is implicit in the method call, so we must alter the function signature slightly.
ferror
feof
fflush
fputc
fgetc
fgets
fputs
fseek
Do not use the C++ standard template library, C++ strings library, C standard I/O library or C standard strings functions. You may use malloc to allocate the buffer.

Behavior should be predictable even for files opened in read/write mode. For example, if you read ABC from the file, write XYZ, and then read GHI, the file should end up containing ABCXYZGHI regardless of the buffering mode. Similarly, writing ABCDEFGHI, repositioning the file pointer to the beginning of the file ("rewinding") and writing XYZ should leave XYZDEFGHI in the file regardless of the buffering mode.

Your test program should verify that writing to a read-only file is an error; reading from a write-only file is an error; and that the the code correctly handles the switch between reading and writing in read/write mode.

Your implementation need not worry about thread-safety.

For the purposes of the assignment you only need to implement the default FULL_BUFFER mode. setvbuf is unsupported.

"a" and "a+" modes have complicated semantics and need not be implemented.

You may crash the program if any unsupported feature is called. See undefined behavior.

An application using your library should #include "file.h" and link with file.o (produced by compiling file.cc with the -c flag. Simulate this by putting your implementation and test program in separate directories (use the -I flag when compiling your test program).

Repeat the benchmarking of Lab 3 for your implementation. This means you will be creating two separate executable programs that use your I/O library.

Skeletons have been provided: file-skel.h and file-skel.cc. You may also reuse or cannibalize any of the work that you did for Lab 3.

For reference, a simplified version of fprintf has been provided in the skeleton code.

Don't forget the BUILD script and README files.


ABCDEFGHIJKLMNOPQ
33


Assignment 3: Standard I/O Library
Original author: Munehiro Fukuda

Revisions 2019: Morris Bernstein

As we have seen in Lab 3, the operating system calls open, close, read, write, llseek, etc. provide an effective interface to the filesystem, but have significant limitations. Performance and convenience can be dramatically improved using a higher-level userland library that provides buffering and data-formatting. Furthermore, programs that use the language-defined standard library are more likely to be portable across operating systems.

The standard I/O library of the C language is available to any C or C++ program that includes the stdio.h (cstdio in C++) header file. Since C predates the object-oriented paradigm, the FILE* object is passed in as the first argument to the various functions that implement file operations, but it is fundamentally an operation on an object.

For this assignment, you will implement a class-based version of the C standard I/O library. The constructor will open the file, and the destructor will close the file.

Since constructors and destructors don't return values, we have to alter the semantics slightly: if an error occurs, throw an exception.

Implement the following methods using only the underlying system calls. See the corresponding man pages. Note that the file argument is implicit in the method call, so we must alter the function signature slightly.
ferror
feof
fflush
fputc
fgetc
fgets
fputs
fseek
Do not use the C++ standard template library, C++ strings library, C standard I/O library or C standard strings functions. You may use malloc to allocate the buffer.

Behavior should be predictable even for files opened in read/write mode. For example, if you read ABC from the file, write XYZ, and then read GHI, the file should end up containing ABCXYZGHI regardless of the buffering mode. Similarly, writing ABCDEFGHI, repositioning the file pointer to the beginning of the file ("rewinding") and writing XYZ should leave XYZDEFGHI in the file regardless of the buffering mode.

Your test program should verify that writing to a read-only file is an error; reading from a write-only file is an error; and that the the code correctly handles the switch between reading and writing in read/write mode.

Your implementation need not worry about thread-safety.

For the purposes of the assignment you only need to implement the default FULL_BUFFER mode. setvbuf is unsupported.

"a" and "a+" modes have complicated semantics and need not be implemented.

You may crash the program if any unsupported feature is called. See undefined behavior.

An application using your library should #include "file.h" and link with file.o (produced by compiling file.cc with the -c flag. Simulate this by putting your implementation and test program in separate directories (use the -I flag when compiling your test program).

Repeat the benchmarking of Lab 3 for your implementation. This means you will be creating two separate executable programs that use your I/O library.

Skeletons have been provided: file-skel.h and file-skel.cc. You may also reuse or cannibalize any of the work that you did for Lab 3.

For reference, a simplified version of fprintf has been provided in the skeleton code.

Don't forget the BUILD script and README files.


ABCDEFGHIJKLMNOPQ
34


Assignment 3: Standard I/O Library
Original author: Munehiro Fukuda

Revisions 2019: Morris Bernstein

As we have seen in Lab 3, the operating system calls open, close, read, write, llseek, etc. provide an effective interface to the filesystem, but have significant limitations. Performance and convenience can be dramatically improved using a higher-level userland library that provides buffering and data-formatting. Furthermore, programs that use the language-defined standard library are more likely to be portable across operating systems.

The standard I/O library of the C language is available to any C or C++ program that includes the stdio.h (cstdio in C++) header file. Since C predates the object-oriented paradigm, the FILE* object is passed in as the first argument to the various functions that implement file operations, but it is fundamentally an operation on an object.

For this assignment, you will implement a class-based version of the C standard I/O library. The constructor will open the file, and the destructor will close the file.

Since constructors and destructors don't return values, we have to alter the semantics slightly: if an error occurs, throw an exception.

Implement the following methods using only the underlying system calls. See the corresponding man pages. Note that the file argument is implicit in the method call, so we must alter the function signature slightly.
ferror
feof
fflush
fputc
fgetc
fgets
fputs
fseek
Do not use the C++ standard template library, C++ strings library, C standard I/O library or C standard strings functions. You may use malloc to allocate the buffer.

Behavior should be predictable even for files opened in read/write mode. For example, if you read ABC from the file, write XYZ, and then read GHI, the file should end up containing ABCXYZGHI regardless of the buffering mode. Similarly, writing ABCDEFGHI, repositioning the file pointer to the beginning of the file ("rewinding") and writing XYZ should leave XYZDEFGHI in the file regardless of the buffering mode.

Your test program should verify that writing to a read-only file is an error; reading from a write-only file is an error; and that the the code correctly handles the switch between reading and writing in read/write mode.

Your implementation need not worry about thread-safety.

For the purposes of the assignment you only need to implement the default FULL_BUFFER mode. setvbuf is unsupported.

"a" and "a+" modes have complicated semantics and need not be implemented.

You may crash the program if any unsupported feature is called. See undefined behavior.

An application using your library should #include "file.h" and link with file.o (produced by compiling file.cc with the -c flag. Simulate this by putting your implementation and test program in separate directories (use the -I flag when compiling your test program).

Repeat the benchmarking of Lab 3 for your implementation. This means you will be creating two separate executable programs that use your I/O library.

Skeletons have been provided: file-skel.h and file-skel.cc. You may also reuse or cannibalize any of the work that you did for Lab 3.

For reference, a simplified version of fprintf has been provided in the skeleton code.

Don't forget the BUILD script and README files.


ABCDEFGHIJKLMNOPQ
35


Assignment 3: Standard I/O Library
Original author: Munehiro Fukuda

Revisions 2019: Morris Bernstein

As we have seen in Lab 3, the operating system calls open, close, read, write, llseek, etc. provide an effective interface to the filesystem, but have significant limitations. Performance and convenience can be dramatically improved using a higher-level userland library that provides buffering and data-formatting. Furthermore, programs that use the language-defined standard library are more likely to be portable across operating systems.

The standard I/O library of the C language is available to any C or C++ program that includes the stdio.h (cstdio in C++) header file. Since C predates the object-oriented paradigm, the FILE* object is passed in as the first argument to the various functions that implement file operations, but it is fundamentally an operation on an object.

For this assignment, you will implement a class-based version of the C standard I/O library. The constructor will open the file, and the destructor will close the file.

Since constructors and destructors don't return values, we have to alter the semantics slightly: if an error occurs, throw an exception.

Implement the following methods using only the underlying system calls. See the corresponding man pages. Note that the file argument is implicit in the method call, so we must alter the function signature slightly.
ferror
feof
fflush
fputc
fgetc
fgets
fputs
fseek
Do not use the C++ standard template library, C++ strings library, C standard I/O library or C standard strings functions. You may use malloc to allocate the buffer.

Behavior should be predictable even for files opened in read/write mode. For example, if you read ABC from the file, write XYZ, and then read GHI, the file should end up containing ABCXYZGHI regardless of the buffering mode. Similarly, writing ABCDEFGHI, repositioning the file pointer to the beginning of the file ("rewinding") and writing XYZ should leave XYZDEFGHI in the file regardless of the buffering mode.

Your test program should verify that writing to a read-only file is an error; reading from a write-only file is an error; and that the the code correctly handles the switch between reading and writing in read/write mode.

Your implementation need not worry about thread-safety.

For the purposes of the assignment you only need to implement the default FULL_BUFFER mode. setvbuf is unsupported.

"a" and "a+" modes have complicated semantics and need not be implemented.

You may crash the program if any unsupported feature is called. See undefined behavior.

An application using your library should #include "file.h" and link with file.o (produced by compiling file.cc with the -c flag. Simulate this by putting your implementation and test program in separate directories (use the -I flag when compiling your test program).

Repeat the benchmarking of Lab 3 for your implementation. This means you will be creating two separate executable programs that use your I/O library.

Skeletons have been provided: file-skel.h and file-skel.cc. You may also reuse or cannibalize any of the work that you did for Lab 3.

For reference, a simplified version of fprintf has been provided in the skeleton code.

Don't forget the BUILD script and README files.


ABCDEFGHIJKLMNOPQ
36


Assignment 3: Standard I/O Library
Original author: Munehiro Fukuda

Revisions 2019: Morris Bernstein

As we have seen in Lab 3, the operating system calls open, close, read, write, llseek, etc. provide an effective interface to the filesystem, but have significant limitations. Performance and convenience can be dramatically improved using a higher-level userland library that provides buffering and data-formatting. Furthermore, programs that use the language-defined standard library are more likely to be portable across operating systems.

The standard I/O library of the C language is available to any C or C++ program that includes the stdio.h (cstdio in C++) header file. Since C predates the object-oriented paradigm, the FILE* object is passed in as the first argument to the various functions that implement file operations, but it is fundamentally an operation on an object.

For this assignment, you will implement a class-based version of the C standard I/O library. The constructor will open the file, and the destructor will close the file.

Since constructors and destructors don't return values, we have to alter the semantics slightly: if an error occurs, throw an exception.

Implement the following methods using only the underlying system calls. See the corresponding man pages. Note that the file argument is implicit in the method call, so we must alter the function signature slightly.
ferror
feof
fflush
fputc
fgetc
fgets
fputs
fseek
Do not use the C++ standard template library, C++ strings library, C standard I/O library or C standard strings functions. You may use malloc to allocate the buffer.

Behavior should be predictable even for files opened in read/write mode. For example, if you read ABC from the file, write XYZ, and then read GHI, the file should end up containing ABCXYZGHI regardless of the buffering mode. Similarly, writing ABCDEFGHI, repositioning the file pointer to the beginning of the file ("rewinding") and writing XYZ should leave XYZDEFGHI in the file regardless of the buffering mode.

Your test program should verify that writing to a read-only file is an error; reading from a write-only file is an error; and that the the code correctly handles the switch between reading and writing in read/write mode.

Your implementation need not worry about thread-safety.

For the purposes of the assignment you only need to implement the default FULL_BUFFER mode. setvbuf is unsupported.

"a" and "a+" modes have complicated semantics and need not be implemented.

You may crash the program if any unsupported feature is called. See undefined behavior.

An application using your library should #include "file.h" and link with file.o (produced by compiling file.cc with the -c flag. Simulate this by putting your implementation and test program in separate directories (use the -I flag when compiling your test program).

Repeat the benchmarking of Lab 3 for your implementation. This means you will be creating two separate executable programs that use your I/O library.

Skeletons have been provided: file-skel.h and file-skel.cc. You may also reuse or cannibalize any of the work that you did for Lab 3.

For reference, a simplified version of fprintf has been provided in the skeleton code.

Don't forget the BUILD script and README files.


ABCDEFGHIJKLMNOPQ
37


Assignment 3: Standard I/O Library
Original author: Mun
 ********************************************* 



 ******* The 16 time fread and read 16384 bits ********
ehiro Fukuda

Revisions 2019: Morris Bernstein

As we have seen in Lab 3, the operating system calls open, close, read, write, llseek, etc. provide an effective interface to the filesystem, but have significant limitations. Performance and convenience can be dramatically improved using a higher-level userland library that provides buffering and data-formatting. Furthermore, programs that use the language-defined standard library are more likely to be portable across operating systems.

The standard I/O library of the C language is available to any C or C++ program that includes the stdio.h (cstdio in C++) header file. Since C predates the object-oriented paradigm, the FILE* object is passed in as the first argument to the various functions that implement file operations, but it is fundamentally an operation on an object.

For this assignment, you will implement a class-based version of the C standard I/O library. The constructor will open the file, and the destructor will close the file.

Since constructors and destructors don't return values, we have to alter the semantics slightly: if an error occurs, throw an exception.

Implement the following methods using only the underlying system calls. See the corresponding man pages. Note that the file argument is implicit in the method call, so we must alter the function signature slightly.
ferror
feof
fflush
fputc
fgetc
fgets
fputs
fseek
Do not use the C++ standard template library, C++ strings library, C standard I/O library or C standard strings functions. You may use malloc to allocate the buffer.

Behavior should be predictable even for files opened in read/write mode. For example, if you read ABC from the file, write XYZ, and then read GHI, the file should end up containing ABCXYZGHI regardless of the buffering mode. Similarly, writing ABCDEFGHI, repositioning the file pointer to the beginning of the file ("rewinding") and writing XYZ should leave XYZDEFGHI in the file regardless of the buffering mode.

Your test program should verify that writing to a read-only file is an error; reading from a write-only file is an error; and that the the code correctly handles the switch between reading and writing in read/write mode.

Your implementation need not worry about thread-safety.

For the purposes of the assignment you only need to implement the default FULL_BUFFER mode. setvbuf is unsupported.

"a" and "a+" modes have complicated semantics and need not be implemented.

You may crash the program if any unsupported feature is called. See undefined behavior.

An application using your library should #include "file.h" and link with file.o (produced by compiling file.cc with the -c flag. Simulate this by putting your implementation and test program in separate directories (use the -I flag when compiling your test program).

Repeat the benchmarking of Lab 3 for your implementation. This means you will be creating two separate executable programs that use your I/O library.

Skeletons have been provided: file-skel.h and file-skel.cc. You may also reuse or cannibalize any of the work that you did for Lab 3.

For reference, a simplified version of fprintf has been provided in the skeleton code.

Don't forget the BUILD script and README files.


ABCDEFGHIJKLMNOPQ
38


Assignment 3: Standard I/O Library
Original author: Munehiro Fukuda

Revisions 2019: Morris Bernstein

As we have seen in Lab 3, the operating system calls open, close, read, write, llseek, etc. provide an effective interface to the filesystem, but have significant limitations. Performance and convenience can be dramatically improved using a higher-level userland library that provides buffering and data-formatting. Furthermore, programs that use the language-defined standard library are more likely to be portable across operating systems.

The standard I/O library of the C language is available to any C or C++ program that includes the stdio.h (cstdio in C++) header file. Since C predates the object-oriented paradigm, the FILE* object is passed in as the first argument to the various functions that implement file operations, but it is fundamentally an operation on an object.

For this assignment, you will implement a class-based version of the C standard I/O library. The constructor will open the file, and the destructor will close the file.

Since constructors and destructors don't return values, we have to alter the semantics slightly: if an error occurs, throw an exception.

Implement the following methods using only the underlying system calls. See the corresponding man pages. Note that the file argument is implicit in the method call, so we must alter the function signature slightly.
ferror
feof
fflush
fputc
fgetc
fgets
fputs
fseek
Do not use the C++ standard template library, C++ strings library, C standard I/O library or C standard strings functions. You may use malloc to allocate the buffer.

Behavior should be predictable even for files opened in read/write mode. For example, if you read ABC from the file, write XYZ, and then read GHI, the file should end up containing ABCXYZGHI regardless of the buffering mode. Similarly, writing ABCDEFGHI, repositioning the file pointer to the beginning of the file ("rewinding") and writing XYZ should leave XYZDEFGHI in the file regardless of the buffering mode.

Your test program should verify that writing to a read-only file is an error; reading from a write-only file is an error; and that the the code correctly handles the switch between reading and writing in read/write mode.

Your implementation need not worry about thread-safety.

For the purposes of the assignment you only need to implement the default FULL_BUFFER mode. setvbuf is unsupported.

"a" and "a+" modes have complicated semantics and need not be implemented.

You may crash the program if any unsupported feature is called. See undefined behavior.

An application using your library should #include "file.h" and link with file.o (produced by compiling file.cc with the -c flag. Simulate this by putting your implementation and test program in separate directories (use the -I flag when compiling your test program).

Repeat the benchmarking of Lab 3 for your implementation. This means you will be creating two separate executable programs that use your I/O library.

Skeletons have been provided: file-skel.h and file-skel.cc. You may also reuse or cannibalize any of the work that you did for Lab 3.

For reference, a simplified version of fprintf has been provided in the skeleton code.

Don't forget the BUILD script and README files.

ABCDEFGHIJKLMNOPQ
39


Assignment 3: Standard I/O Library
Original author: Munehiro Fukuda

Revisions 2019: Morris Bernstein

As we have seen in Lab 3, the operating system calls open, close, read, write, llseek, etc. provide an effective interface to the filesystem, but have significant limitations. Performance and convenience can be dramatically improved using a higher-level userland library that provides buffering and data-formatting. Furthermore, programs that use the language-defined standard library are more likely to be portable across operating systems.

The standard I/O library of the C language is available to any C or C++ program that includes the stdio.h (cstdio in C++) header file. Since C predates the object-oriented paradigm, the FILE* object is passed in as the first argument to the various functions that implement file operations, but it is fundamentally an operation on an object.

For this assignment, you will implement a class-based version of the C standard I/O library. The constructor will open the file, and the destructor will close the file.

Since constructors and destructors don't return values, we have to alter the semantics slightly: if an error occurs, throw an exception.

Implement the following methods using only the underlying system calls. See the corresponding man pages. Note that the file argument is implicit in the method call, so we must alter the function signature slightly.
ferror
feof
fflush
fputc
fgetc
fgets
fputs
fseek
Do not use the C++ standard template library, C++ strings library, C standard I/O library or C standard strings functions. You may use malloc to allocate the buffer.

Behavior should be predictable even for files opened in read/write mode. For example, if you read ABC from the file, write XYZ, and then read GHI, the file should end up containing ABCXYZGHI regardless of the buffering mode. Similarly, writing ABCDEFGHI, repositioning the file pointer to the beginning of the file ("rewinding") and writing XYZ should leave XYZDEFGHI in the file regardless of the buffering mode.

Your test program should verify that writing to a read-only file is an error; reading from a write-only file is an error; and that the the code correctly handles the switch between reading and writing in read/write mode.

Your implementation need not worry about thread-safety.

For the purposes of the assignment you only need to implement the default FULL_BUFFER mode. setvbuf is unsupported.

"a" and "a+" modes have complicated semantics and need not be implemented.

You may crash the program if any unsupported feature is called. See undefined behavior.

An application using your library should #include "file.h" and link with file.o (produced by compiling file.cc with the -c flag. Simulate this by putting your implementation and test program in separate directories (use the -I flag when compiling your test program).

Repeat the benchmarking of Lab 3 for your implementation. This means you will be creating two separate executable programs that use your I/O library.

Skeletons have been provided: file-skel.h and file-skel.cc. You may also reuse or cannibalize any of the work that you did for Lab 3.

For reference, a simplified version of fprintf has been provided in the skeleton code.

Don't forget the BUILD script and README files.


ABCDEFGHIJKLMNOPQ
40


Assignment 3: Standard I/O Library
Original author: Munehiro Fukuda

Revisions 2019: Morris Bernstein

As we have seen in Lab 3, the operating system calls open, close, read, write, llseek, etc. provide an effective interface to the filesystem, but have significant limitations. Performance and convenience can be dramatically improved using a higher-level userland library that provides buffering and data-formatting. Furthermore, programs that use the language-defined standard library are more likely to be portable across operating systems.

The standard I/O library of the C language is available to any C or C++ program that includes the stdio.h (cstdio in C++) header file. Since C predates the object-oriented paradigm, the FILE* object is passed in as the first argument to the various functions that implement file operations, but it is fundamentally an operation on an object.

For this assignment, you will implement a class-based version of the C standard I/O library. The constructor will open the file, and the destructor will close the file.

Since constructors and destructors don't return values, we have to alter the semantics slightly: if an error occurs, throw an exception.

Implement the following methods using only the underlying system calls. See the corresponding man pages. Note that the file argument is implicit in the method call, so we must alter the function signature slightly.
ferror
feof
fflush
fputc
fgetc
fgets
fputs
fseek
Do not use the C++ standard template library, C++ strings library, C standard I/O library or C standard strings functions. You may use malloc to allocate the buffer.

Behavior should be predictable even for files opened in read/write mode. For example, if you read ABC from the file, write XYZ, and then read GHI, the file should end up containing ABCXYZGHI regardless of the buffering mode. Similarly, writing ABCDEFGHI, repositioning the file pointer to the beginning of the file ("rewinding") and writing XYZ should leave XYZDEFGHI in the file regardless of the buffering mode.

Your test program should verify that writing to a read-only file is an error; reading from a write-only file is an error; and that the the code correctly handles the switch between reading and writing in read/write mode.

Your implementation need not worry about thread-safety.

For the purposes of the assignment you only need to implement the default FULL_BUFFER mode. setvbuf is unsupported.

"a" and "a+" modes have complicated semantics and need not be implemented.

You may crash the program if any unsupported feature is called. See undefined behavior.

An application using your library should #include "file.h" and link with file.o (produced by compiling file.cc with the -c flag. Simulate this by putting your implementation and test program in separate directories (use the -I flag when compiling your test program).

Repeat the benchmarking of Lab 3 for your implementation. This means you will be creating two separate executable programs that use your I/O library.

Skeletons have been provided: file-skel.h and file-skel.cc. You may also reuse or cannibalize any of the work that you did for Lab 3.

For reference, a simplified version of fprintf has been provided in the skeleton code.

Don't forget the BUILD script and README files.


ABCDEFGHIJKLMNOPQ
41


Assignment 3: Standard I/O Library
Original author: Munehiro Fukuda

Revisions 2019: Morris Bernstein

As we have seen in Lab 3, the operating system calls open, close, read, write, llseek, etc. provide an effective interface to the filesystem, but have significant limitations. Performance and convenience can be dramatically improved using a higher-level userland library that provides buffering and data-formatting. Furthermore, programs that use the language-defined standard library are more likely to be portable across operating systems.

The standard I/O library of the C language is available to any C or C++ program that includes the stdio.h (cstdio in C++) header file. Since C predates the object-oriented paradigm, the FILE* object is passed in as the first argument to the various functions that implement file operations, but it is fundamentally an operation on an object.

For this assignment, you will implement a class-based version of the C standard I/O library. The constructor will open the file, and the destructor will close the file.

Since constructors and destructors don't return values, we have to alter the semantics slightly: if an error occurs, throw an exception.

Implement the following methods using only the underlying system calls. See the corresponding man pages. Note that the file argument is implicit in the method call, so we must alter the function signature slightly.
ferror
feof
fflush
fputc
fgetc
fgets
fputs
fseek
Do not use the C++ standard template library, C++ strings library, C standard I/O library or C standard strings functions. You may use malloc to allocate the buffer.

Behavior should be predictable even for files opened in read/write mode. For example, if you read ABC from the file, write XYZ, and then read GHI, the file should end up containing ABCXYZGHI regardless of the buffering mode. Similarly, writing ABCDEFGHI, repositioning the file pointer to the beginning of the file ("rewinding") and writing XYZ should leave XYZDEFGHI in the file regardless of the buffering mode.

Your test program should verify that writing to a read-only file is an error; reading from a write-only file is an error; and that the the code correctly handles the switch between reading and writing in read/write mode.

Your implementation need not worry about thread-safety.

For the purposes of the assignment you only need to implement the default FULL_BUFFER mode. setvbuf is unsupported.

"a" and "a+" modes have complicated semantics and need not be implemented.

You may crash the program if any unsupported feature is called. See undefined behavior.

An application using your library should #include "file.h" and link with file.o (produced by compiling file.cc with the -c flag. Simulate this by putting your implementation and test program in separate directories (use the -I flag when compiling your test program).

Repeat the benchmarking of Lab 3 for your implementation. This means you will be creating two separate executable programs that use your I/O library.

Skeletons have been provided: file-skel.h and file-skel.cc. You may also reuse or cannibalize any of the work that you did for Lab 3.

For re
 ********************************************* 



 ********************************************* 


  ----- test write to read only file -----
test ferror:     Success!


 -------------- test rw file --------------- 
 ** test fgetc for 3 times ** 
test fgetc:     Success! 
A
test fgetc:     Success! 
B
test fgetc:     Success! 
C
 ** test fputc for 3 times ** 
test fputc:    Success! 
test fputc:    Success! 
test fputc:    Success! 
 ** test fgets with getting 16 bits ** 
fgets : 

 ** test fputs : string should store at the position (3+3+16 = 21) ** 
 test fputs :    Success! 
 ** test fread: 32 numbers' data with each size 8 bit **
test fread :     Success! 
fread : 
MNOPQ
0



Assignment 3: Standard I/O Library
Original author: Munehiro Fukuda

Revisions 2019: Morris Bernstein

As we have seen in Lab 3, the operating system calls open, close, read, write, llseek, etc. provide an effective interface to the filesystem, 
test fwrite :     Success! 


 -------------- test write-only file  -------------- 
 ** test fputc for 3 times ** 
test fputc :    Success! 
test fputc :    Success! 
test fputc :    Success! 
 ** test fputs **
test fputs :    Success! 
 ** test fwrite **
test fwrite:    Success!
  ----------  test read to write only file -----------
test ferror :    Success! 

 ------- test contructor exception error ---------
Unix system calls, chunk size 1 elapsed time:
	 4.691940069 seconds
	bytes read: 4264394
C standard library I/O fgetc elapsed time elapsed time:
	 0.348532200 seconds
	bytes read: 4264394
My File I/O fgetc  elapsed time:
	 0.336537123 seconds
	bytes read: 4264394
Unix system calls, chunk size 2 elapsed time:
	 2.306203842 seconds
	bytes read: 4264394
C standard library I/O, block size 2 elapsed time:
	 0.190425158 seconds
	bytes read: 4264394
My File I/O calls, chunk size 2 elapsed time:
	 0.022449017 seconds
	bytes read: 4264394
Unix system calls, chunk size 4 elapsed time:
	 1.160516024 seconds
	bytes read: 4264394
C standard library I/O, block size 4 elapsed time:
	 0.096899033 seconds
	bytes read: 4264394
My File I/O calls, chunk size 4 elapsed time:
	 0.018302917 seconds
	bytes read: 4264394
Unix system calls, chunk size 8 elapsed time:
	 0.573938131 seconds
	bytes read: 4264394
C standard library I/O, block size 8 elapsed time:
	 0.048897028 seconds
	bytes read: 4264394
My File I/O calls, chunk size 8 elapsed time:
	 0.014258146 seconds
	bytes read: 4264394
Unix system calls, chunk size 16 elapsed time:
	 0.291296005 seconds
	bytes read: 4264394
C standard library I/O, block size 16 elapsed time:
	 0.025418043 seconds
	bytes read: 4264394
My File I/O calls, chunk size 16 elapsed time:
	 0.012709856 seconds
	bytes read: 4264394
Unix system calls, chunk size 32 elapsed time:
	 0.144680977 seconds
	bytes read: 4264394
C standard library I/O, block size 32 elapsed time:
	 0.013658047 seconds
	bytes read: 4264394
My File I/O calls, chunk size 32 elapsed time:
	 0.011862040 seconds
	bytes read: 4264394
Unix system calls, chunk size 64 elapsed time:
	 0.074669838 seconds
	bytes read: 4264394
C standard library I/O, block size 64 elapsed time:
	 0.007853985 seconds
	bytes read: 4264394
My File I/O calls, chunk size 64 elapsed time:
	 0.014561892 seconds
	bytes read: 4264394
Unix system calls, chunk size 128 elapsed time:
	 0.036442041 seconds
	bytes read: 4264394
C standard library I/O, block size 128 elapsed time:
	 0.004790068 seconds
	bytes read: 4264394
My File I/O calls, chunk size 128 elapsed time:
	 0.012848854 seconds
	bytes read: 4264394
Unix system calls, chunk size 256 elapsed time:
	 0.018537998 seconds
	bytes read: 4264394
C standard library I/O, block size 256 elapsed time:
	 0.003381968 seconds
	bytes read: 4264394
My File I/O calls, chunk size 256 elapsed time:
	 0.012490988 seconds
	bytes read: 4264394
Unix system calls, chunk size 512 elapsed time:
	 0.009486914 seconds
	bytes read: 4264394
C standard library I/O, block size 512 elapsed time:
	 0.002522945 seconds
	bytes read: 4264394
My File I/O calls, chunk size 512 elapsed time:
	 0.011422873 seconds
	bytes read: 4264394
Unix system calls, chunk size 1024 elapsed time:
	 0.005121946 seconds
	bytes read: 4264394
C standard library I/O, block size 1024 elapsed time:
	 0.002199173 seconds
	bytes read: 4264394
My File I/O calls, chunk size 1024 elapsed time:
	 0.011612892 seconds
	bytes read: 4264394
Unix system calls, chunk size 2048 elapsed time:
	 0.003165007 seconds
	bytes read: 4264394
C standard library I/O, block size 2048 elapsed time:
	 0.002505064 seconds
	bytes read: 4264394
My File I/O calls, chunk size 2048 elapsed time:
	 0.010993004 seconds
	bytes read: 4264394
Unix system calls, chunk size 4096 elapsed time:
	 0.001585960 seconds
	bytes read: 4264394
C standard library I/O, block size 4096 elapsed time:
	 0.001969814 seconds
	bytes read: 4264394
My File I/O calls, chunk size 4096 elapsed time:
	 0.011505127 seconds
	bytes read: 4264394
