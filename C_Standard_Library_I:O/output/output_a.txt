 ------------- test read-only file ----------------- 
 ** test fgetc for 3 time ** 
test fgetc:   Success! 
fgetc : A
test fgetc:   Success! 
fgetc : B
test fgetc:   Success! 
fgetc : C

 ** test fgets -  8 bits for 3 times ** 
test fgets :      Success!
fgets string: 
DEFGHIJK
test fgets :      Success!
fgets string: 
LMNOPQ
0
test fgets :      Success!
fgets string: 




Assi

 ** test fread with 1024 numbers with each size i  ** 
 check how many bits to read every time and compare with asked read size 
 ******* The 1 time fread and read 1024 bits ********
gnment 3: Standard I/O Library
Original author: Munehiro Fukuda

Revisions 2019: Morris Bernstein

As we have seen in Lab 3, the operating system calls open, close, read, write, llseek, etc. provide an effective interface to the filesystem, but have significant limitations. Performance and convenience can be dramatically improved using a higher-level userland library that provides buffering and data-formatting. Furthermore, programs that use the language-defined standard library are more likely to be portable across operating systems.

The standard I/O library of the C language is available to any C or C++ program that includes the stdio.h (cstdio in C++) header file. Since C predates the object-oriented paradigm, the FILE* object is passed in as the first argument to the various functions that implement file operations, but it is fundamentally an operation on an object.

For this assignment, you will implement a class-based version of the C standard I/O library. The constructor will open the file, and the de
 ********************************************* 



 ******* The 2 time fread and read 2048 bits ********
structor will close the file.

Since constructors and destructors don't return values, we have to alter the semantics slightly: if an error occurs, throw an exception.

Implement the following methods using only the underlying system calls. See the corresponding man pages. Note that the file argument is implicit in the method call, so we must alter the function signature slightly.
ferror
feof
fflush
fputc
fgetc
fgets
fputs
fseek
Do not use the C++ standard template library, C++ strings library, C standard I/O library or C standard strings functions. You may use malloc to allocate the buffer.

Behavior should be predictable even for files opened in read/write mode. For example, if you read ABC from the file, write XYZ, and then read GHI, the file should end up containing ABCXYZGHI regardless of the buffering mode. Similarly, writing ABCDEFGHI, repositioning the file pointer to the beginning of the file ("rewinding") and writing XYZ should leave XYZDEFGHI in the file regardless of the buffering mode.

Your test program should verify that writing to a read-only file is an error; reading from a write-only file is an error; and that the the code correctly handles the switch between reading and writing in read/write mode.

Your implementation need not worry about thread-safety.

For the purposes of the assignment you only need to implement the default FULL_BUFFER mode. setvbuf is unsupported.

"a" and "a+" modes have complicated semantics and need not be implemented.

You may crash the program if any unsupported feature is called. See undefined behavior.

An application using your library should #include "file.h" and link with file.o (produced by compiling file.cc with the -c flag. Simulate this by putting your implementation and test program in separate directories (use the -I flag when compiling your test program).

Repeat the benchmarking of Lab 3 for your implementation. This means you will be creating two separate executable programs that use your I/O library.

Skeletons have been provided: file-skel.h and file-sk
 ********************************************* 



 ******* The 3 time fread and read 3072 bits ********
el.cc. You may also reuse or cannibalize any of the work that you did for Lab 3.

For reference, a simplified version of fprintf has been provided in the skeleton code.

Don't forget the BUILD script and README files.


ABCDEFGHIJKLMNOPQ
1



Assignment 3: Standard I/O Library
Original author: Munehiro Fukuda

Revisions 2019: Morris Bernstein

As we have seen in Lab 3, the operating system calls open, close, read, write, llseek, etc. provide an effective interface to the filesystem, but have significant limitations. Performance and convenience can be dramatically improved using a higher-level userland library that provides buffering and data-formatting. Furthermore, programs that use the language-defined standard library are more likely to be portable across operating systems.

The standard I/O library of the C language is available to any C or C++ program that includes the stdio.h (cstdio in C++) header file. Since C predates the object-oriented paradigm, the FILE* object is passed in as the first argument to the various functions that implement file operations, but it is fundamentally an operation on an object.

For this assignment, you will implement a class-based version of the C standard I/O library. The constructor will open the file, and the destructor will close the file.

Since constructors and destructors don't return values, we have to alter the semantics slightly: if an error occurs, throw an exception.

Implement the following methods using only the underlying system calls. See the corresponding man pages. Note that the file argument is implicit in the method call, so we must alter the function signature slightly.
ferror
feof
fflush
fputc
fgetc
fgets
fputs
fseek
Do not use the C++ standard template library, C++ strings library, C standard I/O library or C standard strings functions. You may use malloc to allocate the buffer.

Behavior should be predictable even for files opened in read/write mode. For example, if you read ABC from the file, write XYZ, and then read GHI, the file should end up containing ABCXYZGHI regardless of the buffering mode. Similarly, writing ABCDEFGHI, repositioning the file pointer to the beginning of the file ("rewinding") and writing XYZ should leave XYZDEFGHI in the file regardless of the buffering mode.

Your test program should verify that writing to a read-only file is an error; reading from a write-only file is an error; and that the the code correctly handles the switch between reading and writing in read/write mode.

Your implementation need not worry about thread-safety.

For the purposes of the assignment you only need to implement the default FULL_BUFFER mode. setvbuf is unsupported.

"a" and "a+" modes have complicated semantics and need not be implemented.

You may crash the program if any unsupported feature is called. See undefined behavior.

An application using your library should #include "file.h" and link with file.o (produced by compiling file.cc with the -c flag. Simulate this by putting your implementation and test program in separate directories (use the -
 ********************************************* 



 ******* The 4 time fread and read 4096 bits ********
I flag when compiling your test program).

Repeat the benchmarking of Lab 3 for your implementation. This means you will be creating two separate executable programs that use your I/O library.

Skeletons have been provided: file-skel.h and file-skel.cc. You may also reuse or cannibalize any of the work that you did for Lab 3.

For reference, a simplified version of fprintf has been provided in the skeleton code.

Don't forget the BUILD script and README files.


ABCDEFGHIJKLMNOPQ
2



Assignment 3: Standard I/O Library
Original author: Munehiro Fukuda

Revisions 2019: Morris Bernstein

As we have seen in Lab 3, the operating system calls open, close, read, write, llseek, etc. provide an effective interface to the filesystem, but have significant limitations. Performance and convenience can be dramatically improved using a higher-level userland library that provides buffering and data-formatting. Furthermore, programs that use the language-defined standard library are more likely to be portable across operating systems.

The standard I/O library of the C language is available to any C or C++ program that includes the stdio.h (cstdio in C++) header file. Since C predates the object-oriented paradigm, the FILE* object is passed in as the first argument to the various functions that implement file operations, but it is fundamentally an operation on an object.

For this assignment, you will implement a class-based version of the C standard I/O library. The constructor will open the file, and the destructor will close the file.

Since constructors and destructors don't return values, we have to alter the semantics slightly: if an error occurs, throw an exception.

Implement the following methods using only the underlying system calls. See the corresponding man pages. Note that the file argument is implicit in the method call, so we must alter the function signature slightly.
ferror
feof
fflush
fputc
fgetc
fgets
fputs
fseek
Do not use the C++ standard template library, C++ strings library, C standard I/O library or C standard strings functions. You may use malloc to allocate the buffer.

Behavior should be predictable even for files opened in read/write mode. For example, if you read ABC from the file, write XYZ, and then read GHI, the file should end up containing ABCXYZGHI regardless of the buffering mode. Similarly, writing ABCDEFGHI, repositioning the file pointer to the beginning of the file ("rewinding") and writing XYZ should leave XYZDEFGHI in the file regardless of the buffering mode.

Your test program should verify that writing to a read-only file is an error; reading from a write-only file is an error; and that the the code correctly handles the switch between reading and writing in read/write mode.

Your implementation need not worry about thread-safety.

For the purposes of the assignment you only need to implement the default FULL_BUFFER mode. setvbuf is unsupported.

"a" and "a+" modes have complicated semantics and need not be implemented.

You may crash the program if any unsupported feature is called. See undefined behavior.

An application using your library should #include "file.h" and link with file.o (produced by compiling file.cc with the -c flag. Simulate this by putting your implementation and test program in separate directories (use the -I flag when compiling your test program).

Repeat the benchmarking of Lab 3 for your implementation. This means you will be creating two separate executable programs that use your I/O library.

Skeletons have been provided: file-skel.h and file-skel.cc. You may also reuse or cannibalize any of the work that you did for Lab 3.

For reference, a simplified version of fprintf has been provided in the skeleton code.

Don't forget the BUILD script and README files.



ABCDEFGHIJKLMNOPQ
3



Assignment 3: Standard I/O Library
Original author: Munehiro Fukuda

Revisions 2019: Morris Bernstein

As we have seen in Lab 3, the operating system calls open, close, read, write, llseek, etc. provide an effective interface to the filesystem, but have significant limitations. Perform
 ********************************************* 



 ******* The 5 time fread and read 5120 bits ********
ance and convenience can be dramatically improved using a higher-level userland library that provides buffering and data-formatting. Furthermore, programs that use the language-defined standard library are more likely to be portable across operating systems.

The standard I/O library of the C language is available to any C or C++ program that includes the stdio.h (cstdio in C++) header file. Since C predates the object-oriented paradigm, the FILE* object is passed in as the first argument to the various functions that implement file operations, but it is fundamentally an operation on an object.

For this assignment, you will implement a class-based version of the C standard I/O library. The constructor will open the file, and the destructor will close the file.

Since constructors and destructors don't return values, we have to alter the semantics slightly: if an error occurs, throw an exception.

Implement the following methods using only the underlying system calls. See the corresponding man pages. Note that the file argument is implicit in the method call, so we must alter the function signature slightly.
ferror
feof
fflush
fputc
fgetc
fgets
fputs
fseek
Do not use the C++ standard template library, C++ strings library, C standard I/O library or C standard strings functions. You may use malloc to allocate the buffer.

Behavior should be predictable even for files opened in read/write mode. For example, if you read ABC from the file, write XYZ, and then read GHI, the file should end up containing ABCXYZGHI regardless of the buffering mode. Similarly, writing ABCDEFGHI, repositioning the file pointer to the beginning of the file ("rewinding") and writing XYZ should leave XYZDEFGHI in the file regardless of the buffering mode.

Your test program should verify that writing to a read-only file is an error; reading from a write-only file is an error; and that the the code correctly handles the switch between reading and writing in read/write mode.

Your implementation need not worry about thread-safety.

For the purposes of the assignment you only need to implement the default FULL_BUFFER mode. setvbuf is unsupported.

"a" and "a+" modes have complicated semantics and need not be implemented.

You may crash the program if any unsupported feature is called. See undefined behavior.

An application using your library should #include "file.h" and link with file.o (produced by compiling file.cc with the -c flag. Simulate this by putting your implementation and test program in separate directories (use the -I flag when compiling your test program).

Repeat the benchmarking of Lab 3 for your implementation. This means you will be creating two separate executable programs that use your I/O library.

Skeletons have been provided: file-skel.h and file-skel.cc. You may also reuse or cannibalize any of the work that you did for Lab 3.

For reference, a simplified version of fprintf has been provided in the skeleton code.

Don't forget the BUILD script and README files.


ABCDEFGHIJKLMNOPQ
4



Assignment 3: Standard I/O Library
Original author: Munehiro Fukuda

Revisions 2019: Morris Bernstein

As we have seen in Lab 3, the operating system calls open, close, read, write, llseek, etc. provide an effective interface to the filesystem, but have significant limitations. Performance and convenience can be dramatically improved using a higher-level userland library that provides buffering and data-formatting. Furthermore, programs that use the language-defined standard library are more likely to be portable across operating systems.

The standard I/O library of the C language is available to any C or C++ program that includes the stdio.h (cstdio in C++) header file. Since C predates the object-oriented paradigm, the FILE* object is passed in as the first argument to the various functions that implement file operations, but it is fundamentally an operation on an object.

For this assignment, you will implement a class-based version of the C standard I/O library. The constructor will open the file, and the destructor will close the file.

Since constructors and destructors don't return values, we have to alter the semantics slightly: if an error occurs, throw an exception.

Implement the following methods using only the underlying system calls. See the corresponding man pages. Note that the file argument is implicit in the method call, so we must alter the function signature slightly.
ferror
feof
fflush
fputc
fgetc
fgets
fputs
fseek
Do not use the C++ standard template library, C++ strings library, C standard I/O library or C standard strings functions. You may use malloc to allocate the buffer.

Behavior should be predictable even for files opened in read/write mode. For example, if you read ABC from the file, write XYZ, and then read GHI, the file should end up containing ABCXYZGHI regardless of the buffering mode. Similarly, writing ABCDEFGHI, repositioning the file pointer to the beginning of the file ("rewinding") and writing XYZ should leave XYZDEFGHI in the file regardless of the buffering mode.

Your test program should verify that writing
 ********************************************* 



 ******* The 6 time fread and read 6144 bits ********
 to a read-only file is an error; reading from a write-only file is an error; and that the the code correctly handles the switch between reading and writing in read/write mode.

Your implementation need not worry about thread-safety.

For the purposes of the assignment you only need to implement the default FULL_BUFFER mode. setvbuf is unsupported.

"a" and "a+" modes have complicated semantics and need not be implemented.

You may crash the program if any unsupported feature is called. See undefined behavior.

An application using your library should #include "file.h" and link with file.o (produced by compiling file.cc with the -c flag. Simulate this by putting your implementation and test program in separate directories (use the -I flag when compiling your test program).

Repeat the benchmarking of Lab 3 for your implementation. This means you will be creating two separate executable programs that use your I/O library.

Skeletons have been provided: file-skel.h and file-skel.cc. You may also reuse or cannibalize any of the work that you did for Lab 3.

For reference, a simplified version of fprintf has been provided in the skeleton code.

Don't forget the BUILD script and README files.


ABCDEFGHIJKLMNOPQ
5



Assignment 3: Standard I/O Library
Original author: Munehiro Fukuda

Revisions 2019: Morris Bernstein

As we have seen in Lab 3, the operating system calls open, close, read, write, llseek, etc. provide an effective interface to the filesystem, but have significant limitations. Performance and convenience can be dramatically improved using a higher-level userland library that provides buffering and data-formatting. Furthermore, programs that use the language-defined standard library are more likely to be portable across operating systems.

The standard I/O library of the C language is available to any C or C++ program that includes the stdio.h (cstdio in C++) header file. Since C predates the object-oriented paradigm, the FILE* object is passed in as the first argument to the various functions that implement file operations, but it is fundamentally an operation on an object.

For this assignment, you will implement a class-based version of the C standard I/O library. The constructor will open the file, and the destructor will close the file.

Since constructors and destructors don't return values, we have to alter the semantics slightly: if an error occurs, throw an exception.

Implement the following methods using only the underlying system calls. See the corresponding man pages. Note that the file argument is implicit in the method call, so we must alter the function signature slightly.
ferror
feof
fflush
fputc
fgetc
fgets
fputs
fseek
Do not use the C++ standard template library, C++ strings library, C standard I/O library or C standard strings functions. You may use malloc to allocate the buffer.

Behavior should be predictable even for files opened in read/write mode. For example, if you read ABC from the file, write XYZ, and then read GHI, the file should end up containing ABCXYZGHI regardless of the buffering mode. Similarly, writing ABCDEFGHI, repositioning the file pointer to the beginning of the file ("rewinding") and writing XYZ should leave XYZDEFGHI in the file regardless of the buffering mode.

Your test program should verify that writing to a read-only file is an error; reading from a write-only file is an error; and that the the code correctly handles the switch between reading and writing in read/write mode.

Your implementation need not worry about thread-safety.

For the purposes of the assignment you only need to implement the default FULL_BUFFER mode. setvbuf is unsupported.

"a" and "a+" modes have complicated semantics and need not be implemented.

You may crash the program if any unsupported feature is called. See undefined behavior.

An application using your library should #include "file.h" and link with file.o (produced by compiling file.cc with the -c flag. Simulate this by putting your implementation and test program in separate directories (use the -I flag when compiling your test program).

Repeat the benchmarking of Lab 3 for your implementation. This means you will be creating two separate executable programs that use your I/O library.

Skeletons have been provided: file-skel.h and file-skel.cc. You may also reuse or cannibalize any of the work that you did for Lab 3.

For reference, a simplified version of fprintf has been provided in the skeleton code.

Don't forget the BUILD script and README files.


ABCDEFGHIJKLMNOPQ
6



Assignment 3: Standard I/O Library
Original author: Munehiro Fukuda

Revisions 2019: Morris Bernstein

As we have seen in Lab 3, the operating system calls open, close, read, write, llseek, etc. provide an effective interface to the filesystem, but have significant limitations. Performance and convenience can be dramatically improved using a higher-level userland library that provides buffering and data-formatting. Furthermore, programs that use the language-defined standard library are more likely to be portable across operating systems.

The standard I/O library of the C language is available to any C or C++ program that includes the stdio.h (cstdio in C++) header file. Since C predates the object-oriented paradigm, the FILE* object is passed in as the first argument to the various functions that implement file operations, but it is fundamentally an operation on an object.

For this assignment, you will implement a class-based version of the C standard I/O library. The constructor will open the file, and the destructor will close the file.

Since constructors and destructors don't return values, we have to alter the semantics slightly: if an error occurs, throw an exception.

Implement the following methods using only the underlying system calls. See the corresponding man pages. Note that the file argument is implicit in the method call, so we must alter the function signature slightly.
ferror
feof
fflush
fputc
fgetc
fgets
fputs
fseek
Do not use the C++ standard template library, C++ strings library, C standard I/O library or C standard strings functions. You may u
 ********************************************* 



 ******* The 7 time fread and read 7168 bits ********
se malloc to allocate the buffer.

Behavior should be predictable even for files opened in read/write mode. For example, if you read ABC from the file, write XYZ, and then read GHI, the file should end up containing ABCXYZGHI regardless of the buffering mode. Similarly, writing ABCDEFGHI, repositioning the file pointer to the beginning of the file ("rewinding") and writing XYZ should leave XYZDEFGHI in the file regardless of the buffering mode.

Your test program should verify that writing to a read-only file is an error; reading from a write-only file is an error; and that the the code correctly handles the switch between reading and writing in read/write mode.

Your implementation need not worry about thread-safety.

For the purposes of the assignment you only need to implement the default FULL_BUFFER mode. setvbuf is unsupported.

"a" and "a+" modes have complicated semantics and need not be implemented.

You may crash the program if any unsupported feature is called. See undefined behavior.

An application using your library should #include "file.h" and link with file.o (produced by compiling file.cc with the -c flag. Simulate this by putting your implementation and test program in separate directories (use the -I flag when compiling your test program).

Repeat the benchmarking of Lab 3 for your implementation. This means you will be creating two separate executable programs that use your I/O library.

Skeletons have been provided: file-skel.h and file-skel.cc. You may also reuse or cannibalize any of the work that you did for Lab 3.

For reference, a simplified version of fprintf has been provided in the skeleton code.

Don't forget the BUILD script and README files.


ABCDEFGHIJKLMNOPQ
7



Assignment 3: Standard I/O Library
Original author: Munehiro Fukuda

Revisions 2019: Morris Bernstein

As we have seen in Lab 3, the operating system calls open, close, read, write, llseek, etc. provide an effective interface to the filesystem, but have significant limitations. Performance and convenience can be dramatically improved using a higher-level userland library that provides buffering and data-formatting. Furthermore, programs that use the language-defined standard library are more likely to be portable across operating systems.

The standard I/O library of the C language is available to any C or C++ program that includes the stdio.h (cstdio in C++) header file. Since C predates the object-oriented paradigm, the FILE* object is passed in as the first argument to the various functions that implement file operations, but it is fundamentally an operation on an object.

For this assignment, you will implement a class-based version of the C standard I/O library. The constructor will open the file, and the destructor will close the file.

Since constructors and destructors don't return values, we have to alter the semantics slightly: if an error occurs, throw an exception.

Implement the following methods using only the underlying system calls. See the corresponding man pages. Note that the file argument is implicit in the method call, so we must alter the function signature slightly.
ferror
feof
fflush
fputc
fgetc
fgets
fputs
fseek
Do not use the C++ standard template library, C++ strings library, C standard I/O library or C standard strings functions. You may use malloc to allocate the buffer.

Behavior should be predictable even for files opened in read/write mode. For example, if you read ABC from the file, write XYZ, and then read GHI, the file should end up containing ABCXYZGHI regardless of the buffering mode. Similarly, writing ABCDEFGHI, repositioning the file pointer to the beginning of the file ("rewinding") and writing XYZ should leave XYZDEFGHI in the file regardless of the buffering mode.

Your test program should verify that writing to a read-only file is an error; reading from a write-only file is an error; and that the the code correctly handles the switch between reading and writing in read/write mode.

Your implementation need not worry about thread-safety.

For the purposes of the assignment you only need to implement the default FULL_BUFFER mode. setvbuf is unsupported.

"a" and "a+" modes have complicated semantics and need not be implemented.

You may crash the program if any unsupported feature is called. See undefined behavior.

An application using your library should #include "file.h" and link with file.o (produced by compiling file.cc with the -c flag. Simulate this by putting your implementation and test program in separate directories (use the -I flag when compiling your test program).

Repeat the benchmarking of Lab 3 for your implementation. This means you will be creating two separate executable programs that use your I/O library.

Skeletons have been provided: file-skel.h and file-skel.cc. You may also reuse or cannibalize any of the work that you did for Lab 3.

For reference, a simplified version of fprintf has been provided in the skeleton code.

Don't forget the BUILD script and README files.


ABCDEFGHIJKLMNOPQ
8



Assignment 3: Standard I/O Library
Original author: Munehiro Fukuda

Revisions 2019: Morris Bernstein

As we have seen in Lab 3, the operating system calls open, close, read, write, llseek, etc. provide an effective interface to the filesystem, but have significant limitations. Performance and convenience can be dramatically improved using a higher-level userland library that provides buffering and data-formatting. Furthermore, programs that use the language-defined standard library are more likely to be portable across operating systems.

The standard I/O library of the C language is available to any C or C++ program that includes the stdio.h (cstdio in C++) header file. Since C predates the object-oriented paradigm, the FILE* object is passed in as the first argument to the various functions that implement file operations, but it is fundamentally an operation on an object.

For this assignment, you will implement a class-based version of the C standard I/O library. The constructor will open the file, and the destructor will close the file.

Since constructors and destructors don't return values, we have to alter the semantics slightly: if an error occurs, throw an exception.

Implement the following methods using only the underlying system calls. See the corresponding man pages. Note that the file argument is implicit in the method call, so we must alter the function signature slightly.
ferror
feof
fflush
fputc
fgetc
fgets
fputs
fseek
Do not use the C++ standard template library, C++ strings library, C standard I/O library or C standard strings functions. You may use malloc to allocate the buffer.

Behavior should be predictable even for files opened in read/write mode. For example, if you read ABC from the file, write XYZ, and then read GHI, the file should end up containing ABCXYZGHI regardless of the buffering mode. Similarly, writing ABCDEFGHI, repositioning the file pointer to the beginning of the file ("rewinding") and writing XYZ should leave XYZDEFGHI in the file regardless of the buffering mode.

Your test program should verify that writing to a read-only file is an error; re
 ********************************************* 



 ******* The 8 time fread and read 8192 bits ********
epeat the benchmarking of Lab 3 for your implementation. This means you will be creating two separate executable programs that use your I/O library.

Skeletons have been provided: file-skel.h and file-skel.cc. You may also reuse or cannibalize any of the work that you did for Lab 3.

For reference, a simplified version of fprintf has been provided in the skeleton code.

Don't forget the BUILD script and README files.


ABCDEFGHIJKLMNOPQ
10



Assignment 3: Standard I/O Library
Original author: Munehiro Fukuda

Revisions 2019: Morris Bernstein

As we have seen in Lab 3, the operating system calls open, close, read, write, llseek, etc. provide an effective interface to the filesystem, but have significant limitations. Performance and convenience can be dramatically improved using a higher-level userland library that provides buffering and data-formatting. Furthermore, programs that use the language-defined standard library are more likely to be portable across operating systems.

The standard I/O library of the C language is available to any C or C++ program that includes the stdio.h (cstdio in C++) header file. Since C predates the object-oriented paradigm, the FILE* object is passed in as the first argument to the various functions that implement file operations, but it is fundamentally an operation on an object.

For this assignment, you will implement a class-based version of the C standard I/O library. The constructor will open the file, and the destructor will close the file.

Since constructors and destructors don't return values, we have to alter the semantics slightly: if an error occurs, throw an exception.

Implement the following methods using only the underlying system calls. See the corresponding man pages. Note that the file argument is implicit in the method call, so we must alter the function signature slightly.
ferror
feof
fflush
fputc
fgetc
fgets
fputs
fseek
Do not use the C++ standard template library, C++ strings library, C standard I/O library or C standard strings functions. You may use malloc to allocate the buffer.

Behavior should be predictable even for files opened in read/write mode. For example, if you read ABC from the file, write XYZ, and then read GHI, the file should end up containing ABCXYZGHI regardless of the buffering mode. Similarly, writing ABCDEFGHI, repositioning the file pointer to the beginning of the file ("rewinding") and writing XYZ should leave XYZDEFGHI in the file regardless of the buffering mode.

Your test program should verify that writing to a read-only file is an error; reading from a write-only file is an error; and that the the code correctly handles the switch between reading and writing in read/write mode.

Your implementation need not worry about thread-safety.

For the purposes of the assignment you only need to implement the default FULL_BUFFER mode. setvbuf is unsupported.

"a" and "a+" modes have complicated semantics and need not be implemented.

You may crash the program if any unsupported feature is called. See undefined behavior.

An application using your library should #include "file.h" and link with file.o (produced by compiling file.cc with the -c flag. Simulate this by putting your implementation and test program in separate directories (use the -I flag when compiling your test program).

Repeat the benchmarking of Lab 3 for your implementation. This means you will be creating two separate executable programs that use your I/O library.

Skeletons have been provided: file-skel.h and file-skel.cc. You may also reuse or cannibalize any of the work that you did for Lab 3.

For reference, a simplified version of fprintf has been provided in the skeleton code.

Don't forget the BUILD script and README files.

ABCDEFGHIJKLMNOPQ
11


Assignment 3: Standard I/O Library
Original author: Munehiro Fukuda

Revisions 2019: Morris Bernstein

As we have seen in Lab 3, the operating system calls open, close, read, write, llseek, etc. provide an effective interface to the filesystem, but have significant limitations. Performance and convenience can be dramatically improved using a higher-level uULL_BUFFER mode. setvbuf is unsupported.

"a" and "a+" modes have complicated semantics and need not be implemented.

You may crash the program if any unsupported feature is called. See undefined behavior.

An application using your library should #include "file.h" and link with file.o (produced by compiling file.cc with the -c flag. Simulate this by putting your implementation and test program in separate directories (use the -I flag when compiling your test program).

Repeat the benchmarking of Lab 3 for your implementation. This means you will be creating two separate executable programs that use your I/O library.

Skeletons have been provided: file-skel.h and file-skel.cc. You may also reuse or cannibalize any of the work that you did for Lab 3.

For reference, a simplified version of fprintf has been provided in the skeleton code.

Don't forget the BUILD script and README files.


ABCDEFGHIJKLMNOPQ
8



Assignment 3: Standard I/O Library
Original author: Munehiro Fukuda

Revisions 2019: Morris Bernstein

As we have seen in Lab 3, the operating system calls open, close, read, write, llseek, etc. provide an effective interface to the filesystem, but have significant limitations. Performance and convenience can be dramatically improved using a higher-level userland library that provides buffering and data-formatting. Furthermore, programs that use the language-defined standard library are more likely to be portable across operating systems.

The standard I/O library of the C language is available to any C or C++ program that includes the stdio.h (cstdio in C++) header file. Since C predates the object-oriented paradigm, the FILE* object is passed in as the first argument to the various functions that implement file operations, but it is fundamentally an operation on an object.

For this assignment, you will implement a class-based version of the C standard I/O library. The constructor will open the file, and the destructor will close the file.

Since constructors and destructors don't return values, we have to alter the semantics slightly: if an error occurs, throw an exception.

Implement the following methods using only the underlying system calls. See the corresponding man pages. Note that the file argument is implicit in the method call, so we must alter the function signature slightly.
ferror
feof
fflush
fputc
fgetc
fgets
fputs
fseek
Do not use the C++ standard template library, C++ strings library, C standard I/O library or C standard strings functions. You may use malloc to allocate the buffer.

Behavior should be predictable even for files opened in read/write mode. For example, if you read ABC from the file, write XYZ, and then read GHI, the file should end up containing ABCXYZGHI regardless of the buffering mode. Similarly, writing ABCDEFGHI, repositioning the file pointer to the beginning of the file ("rewinding") and writing XYZ should leave XYZDEFGHI in the file regardless of the buffering mode.

Your test program should verify that writing to a read-only file is an error; re
 ********************************************* 



 ******* The 9 time fread and read 9216 bits ********
serland library that provides buffering and data-formatting. Furthermore, programs that use the language-defined standard library are more likely to be portable across operating systems.

The standard I/O library of the C language is available to any C or C++ program that includes the stdio.h (cstdio in C++) header file. Since C predates the object-oriented paradigm, the FILE* object is passed in as the first argument to the various functions that implement file operations, but it is fundamentally an operation on an object.

For this assignment, you will implement a class-based version of the C standard I/O library. The constructor will open the file, and the destructor will close the file.

Since constructors and destructors don't return values, we have to alter the semantics slightly: if an error occurs, throw an exception.

Implement the following methods using only the underlying system calls. See the corresponding man pages. Note that the file argument is implicit in the method call, so we must alter the function signature slightly.
ferror
feof
fflush
fputc
fgetc
fgets
fputs
fseek
Do not use the C++ standard template library, C++ strings library, C standard I/O library or C standard strings functions. You may use malloc to allocate the buffer.

Behavior should be predictable even for files opened in read/write mode. For example, if you read ABC from the file, write XYZ, and then read GHI, the file should end up containing ABCXYZGHI regardless of the buffering mode. Similarly, writing ABCDEFGHI, repositioning the file pointer to the beginning of the file ("rewinding") and writing XYZ should leave XYZDEFGHI in the file regardless of the buffering mode.

Your test program should verify that writing to a read-only file is an error; reading from a write-only file is an error; and that the the code correctly handles the switch between reading and writing in read/write mode.

Your implementation need not worry about thread-safety.

For the purposes of the assignment you only need to implement the default FULL_BUFFER mode. setvbuf is unsupported.

"a" and "a+" modes have complicated semantics and need not be implemented.

You may crash the program if any unsupported feature is called. See undefined behavior.

An application using your library should #include "file.h" and link with file.o (produced by compiling file.cc with the -c flag. Simulate this by putting your implementation and test program in separate directories (use the -I flag when compiling your test program).

Repeat the benchmarking of Lab 3 for your implementation. This means you will be creating two separate executable programs that use your I/O library.

Skeletons have been provided: file-skel.h and file-skel.cc. You may also reuse or cannibalize any of the work that you did for Lab 3.

For reference, a simplified version of fprintf has been provided in the skeleton code.

Don't forget the BUILD script and README files.


ABCDEFGHIJKLMNOPQ
12


Assignment 3: Standard I/O Library
Original author: Munehiro Fukuda

Revisions 2019: Morris Bernstein

As we have seen in Lab 3, the operating system calls open, close, read, write, llseek, etc. provide an effective interface to the filesystem, but have significant limitations. Performance and convenience can be dramatically improved using a higher-level userland library that provides buffering and data-formatting. Furthermore, programs that use the language-defined standard library are more likely to be portable across operating systems.

The standard I/O library of the C language is available to any C or C++ program that includes the stdio.h (cstdio in C++) header file. Since C predates the object-oriented paradigm, the FILE* object is passed in as the first argument to the various functions that implement file operations, but it is fundamentally an operation on an object.

For this assignment, you will implement a class-based version of the C standard I/O library. The constructor will open the file, and the destructor will close the file.

Since constructors and destructors don't return values, we have to alter the semantics slightly: if an error occurs, throw an exception.

Implement the following methods using only the underlying system calls. See the corresponding man pages. Note that the file argument is implicit in the method call, so we must alter the function signature slightly.
ferror
feof
fflush
fputc
fgetc
fgets
fputs
fseek
Do not use the C++ standard template library, C++ strings library, C standard I/O library or C standard strings functions. You may use malloc to allocate the buffer.

Behavior should be predictable even for files opened in read/write mode. For example, if you read ABC from the file, write XYZ, and then read GHI, the file should end up containing ABCXYZGHI regardless of the buffering mode. Similarly, writing ABCDEFGHI, repositioning the file pointer to the beginning of the file ("rewinding") and writing XYZ should leave XYZDEFGHI in the file regardless of the buffering mode.

Your test program should verify that writing to a read-only file is an error; reading from a write-only file is an error; and that the the code correctly handles the switch between reading and writing in read/write mode.

Your implementation need not worry about thread-safety.

For the purposes of the assignment you only need to implement the default FULL_BUFFER mode. setvbuf is unsupported.

"a" and "a+" modes have complicated semantics and need not be implemented.

You may crash the program if any unsupported feature is called. See undefined behavior.

An application using your library should #include "file.h" and link with file.o (produced by compiling file.cc with the -c flag. Simulate this by putting your implementation and test program in separate directories (use the -I flag when compiling your test program).

Repeat the benchmarking of Lab 3 for your implementation. This means you will be creating two separate executable programs that use your I/O library.

Skeletons have been provided: file-skel.h and file-skel.cc. You may also reuse or cannibalize any of the work that you did for Lab 3.

For reference, a simplified version of fprintf has been provided in the skeleton code.

Don't forget the BUILD script and README files.


ABCDEFGHIJKLMNOPQ
13


Assignment 3: Standard I/O Library
Original author: Munehiro Fukuda

Revisions 2019: Morris Bernstein

As we have seen in Lab 3, the operating system calls open, close, read, write, llseek, etc. provide an effective interface to the filesystem, but have significant limitations. Performance and convenience can be dramatically improved using a higher-level userland library that provides buffering and data-formatting. Furthermore, programs that use the language-defined standard library are more likely to be portable across operating systems.

The standard I/O library of the C language is available to any C or C++ program that includes the stdio.h (cstdio in C++) header file. Since C predates the object-oriented paradigm, the FILE* object is passed in as the first argument to the various functions that implement file operations, but it is fundamentally an operation on an object.

For this assignment, you will implement a class-based version of the C standard I/O library. The constructor will open the file, and the destructor will close the file.

Since constructors and destructors don't return values, we have to alter the semantics slightly: if an error occurs, throw an exception.

Implement the following methods using only the underlying system calls. See the corresponding man pages. Note that the file argument is implicit in the method call, so we must alter the function signature slightly.
ferror
feof
fflush
fputc
fgetc
fgets
fputs
fseek
Do not use the C++ standard template library, C++ strings library, C standard I/O library or C standard strings functions. You may use malloc to allocate the buffer.

Behavior should be predictable even for files opened in read/write mode. For example, if you read ABC from the file, write XYZ, and then read GHI, the file should end up containing ABCXYZGHI regardless of the buffering mode. Similarly, writing ABCDEFGHI, repositioning the file pointer to the beginning of the file ("rewinding") and writing XYZ should leave XYZDEFGHI in the file regardless of the buffering mode.

Your test program should verify that writing to a read-only file is an error; reading from a write-only file is an error; and that the the code correctly handles the switch between reading and writing in read/write mode.

Your implementation need not worry about thread-safety.

For the purposes of the assignment you only need to implement the default FULL_BUFFER mode. setvbuf is unsupported.

"a" and "a+" modes have complicated semantics and need not be implemented.

You may crash the program if any unsupported feature is called. See undefined behavior.

An application using your library should #include "file.h" and link with file.o (produced by compiling file.cc with the -c flag. Simulate this by putting your implementation and test program in separate directories (use the -I flag when compiling your test program).

Repeat the benchmarking of Lab 3 for your implementation. This m
 ********************************************* 



 ******* The 10 time fread and read 10240 bits ********
eans you will be creating two separate executable programs that use your I/O library.

Skeletons have been provided: file-skel.h and file-skel.cc. You may also reuse or cannibalize any of the work that you did for Lab 3.

For reference, a simplified version of fprintf has been provided in the skeleton code.

Don't forget the BUILD script and README files.


ABCDEFGHIJKLMNOPQ
14


Assignment 3: Standard I/O Library
Original author: Munehiro Fukuda

Revisions 2019: Morris Bernstein

As we have seen in Lab 3, the operating system calls open, close, read, write, llseek, etc. provide an effective interface to the filesystem, but have significant limitations. Performance and convenience can be dramatically improved using a higher-level userland library that provides buffering and data-formatting. Furthermore, programs that use the language-defined standard library are more likely to be portable across operating systems.

The standard I/O library of the C language is available to any C or C++ program that includes the stdio.h (cstdio in C++) header file. Since C predates the object-oriented paradigm, the FILE* object is passed in as the first argument to the various functions that implement file operations, but it is fundamentally an operation on an object.

For this assignment, you will implement a class-based version of the C standard I/O library. The constructor will open the file, and the destructor will close the file.

Since constructors and destructors don't return values, we have to alter the semantics slightly: if an error occurs, throw an exception.

Implement the following methods using only the underlying system calls. See the corresponding man pages. Note that the file argument is implicit in the method call, so we must alter the function signature slightly.
ferror
feof
fflush
fputc
fgetc
fgets
fputs
fseek
Do not use the C++ standard template library, C++ strings library, C standard I/O library or C standard strings functions. You may use malloc to allocate the buffer.

Behavior should be predictable even for files opened in read/write mode. For example, if you read ABC from the file, write XYZ, and then read GHI, the file should end up containing ABCXYZGHI regardless of the buffering mode. Similarly, writing ABCDEFGHI, repositioning the file pointer to the beginning of the file ("rewinding") and writing XYZ should leave XYZDEFGHI in the file regardless of the buffering mode.

Your test program should verify that writing to a read-only file is an error; reading from a write-only file is an error; and that the the code correctly handles the switch between reading and writing in read/write mode.

Your implementation need not worry about thread-safety.

For the purposes of the assignment you only need to implement the default FULL_BUFFER mode. setvbuf is unsupported.

"a" and "a+" modes have complicated semantics and need not be implemented.

You may crash the program if any unsupported feature is called. See undefined behavior.

An application using your library should #include "file.h" and link with file.o (produced by compiling file.cc with the -c flag. Simulate this by putting your implementation and test program in separate directories (use the -I flag when compiling your test program).

Repeat the benchmarking of Lab 3 for your implementation. This means you will be creating two separate executable programs that use your I/O library.

Skeletons have been provided: file-skel.h and file-skel.cc. You may also reuse or cannibalize any of the work that you did for Lab 3.

For reference, a simplified version of fprintf has been provided in the skeleton code.

Don't forget the BUILD script and README files.


ABCDEFGHIJKLMNOPQ
15


Assignment 3: Standard I/O Library
Original author: Munehiro Fukuda

Revisions 2019: Morris Bernstein

As we have seen in Lab 3, the operating system calls open, close, read, write, llseek, etc. provide an effective interface to the filesystem, but have significant limitations. Performance and convenience can be dramatically improved using a higher-level userland library that provides buffering and data-formatting. Furthermore, programs that use the language-defined standard library are more likely to be portable across operating systems.

The standard I/O library of the C language is available to any C or C++ program that includes the stdio.h (cstdio in C++) header file. Since C predates the object-oriented paradigm, the FILE* object is passed in as the first argument to the various functions that implement file operations, but it is fundamentally an operation on an object.

For this assignment, you will implement a class-based version of the C standard I/O library. The constructor will open the file, and the destructor will close the file.

Since constructors and destructors don't return values, we have to alter the semantics slightly: if an error occurs, throw an exception.

Implement the following methods using only the underlying system calls. See the corresponding man pages. Note that the file argument is implicit in the method call, so we must alter the function signature slightly.
ferror
feof
fflush
fputc
fgetc
fgets
fputs
fseek
Do not use the C++ standard template library, C++ strings library, C standard I/O library or C standard strings functions. You may use malloc to allocate the buffer.

Behavior should be predictable even for files opened in read/write mode. For example, if you read ABC from the file, write XYZ, and then read GHI, the file should end up containing ABCXYZGHI regardless of the buffering mode. Similarly, writing ABCDEFGHI, repositioning the file pointer to the beginning of the file ("rewinding") and writing XYZ should leave XYZDEFGHI in the file regardless of the buffering mode.

Your test program should verify that writing to a read-only file is an error; reading from a write-only file is an error; and that the the code correctly handles the switch between reading and writing in read/write mode.

Your implementation need not worry about thread-safety.

For the purposes of the assignment you only need to implement the default FULL_BUFFER mode. setvbuf is unsupported.

"a" and "a+" modes have complicated semantics and need not be implemented.

You may crash the program if any unsupported feature is called. See undefined behavior.

An application using your library should #include "file.h" and link with file.o (produced by compiling file.cc with the -c flag. Simulate this by putting your implementation and test program in separate directories (use the -I flag when compiling your test program).

Repeat the benchmarking of Lab 3 for your implementation. This means you will be creating two separate executable programs that use your I/O library.

Skeletons have been provided: file-skel.h and file-skel.cc. You may also reuse or cannibalize any of the work that you did for Lab 3.

For reference, a simplified version of fprintf has been provided in the skeleton code.

Don't forget the BUILD script and README files.


ABCDEFGHIJKLMNOPQ
16


Assignment 3: Standard I/O Library
Original author: Munehiro Fukuda

Revisions 2019: Morris Bernstein

As we have seen in Lab 3, the operating system calls open, close, read, write, llseek, etc. provide an effective interface to the filesystem, but have significant limitations. Performance and convenience can be dramatically improved using a higher-level userland library that provides buffering and data-formatting. Furthermore, programs that use the language-defined standard library are more likely to be portable across operating systems.

The standard I/O library of the C language is available to any C or C++ program that includes the stdio.h (cstdio in C++) header file. Since C predates the object-oriented paradigm, the FILE* object is passed in as the first argument to the various functions that implement file operations, but it is fundamentally an operation on an object.

For this assignment, you will implement a class-based version of the C standard I/O library. The constructor will open the file, and the destructor will close the file.

Since constructors and destructors don't return values, we have to alter the semantics slightly: if an error occurs, throw an exception.

Implement the following methods using only the underlying system calls. See the corresponding man pages. Note that the file argument is implicit in the method call, so we must alter the function signature slightly.
ferror
feof
fflush
fputc
fgetc
fgets
fputs
fseek
Do not use the C++ standard template library, C++ strings library, C standard I/O library or C standard strings functions. You may use malloc to allocate the buffer.

Behavior should be predictable even for files opened in read/write mode. For example, if you read ABC from the file, write XYZ, and then read GHI, the file should end up containing ABCXYZGHI regardless of the buffering mode. Similarly, writing ABCDEFGHI, repositioning the file pointer to the beginning of the file ("rewinding") and writing XYZ should leave XYZDEFGHI in the file regardless of the buffering mode.

Your test program should verify that writing to a read-only file is an error; reading from a write-only file is an error; and that the the code correctly handles the switch between reading and writing in read/write mode.

Your implementation need not worry about thread-safety.

For the purposes of the assignment you only need to implement the default FULL_BUFFER mode. setvbuf is unsupported.

"a" and "a+" modes have complicated semantics and need not be implemented.

You may crash the program if any unsupported feature is called. See undefined behavior.

An application using your library should #include "file.h" and link with file.o (produced by compiling file.cc with the -c flag. Simulate this by putting your implementation and test program in separate directories (use the -I flag when compiling your test program).

Repeat the benchmarking of Lab 3 for your implementation. This means you will be creating two separate executable programs that use your I/O library.

Skeletons have been provided: file-skel.h and file-skel.cc. You may also reuse or cannibalize any of the work that you did for Lab 3.

For reference, a simplified version of fprintf has been provi
 ********************************************* 



 ******* The 11 time fread and read 11264 bits ********
ded in the skeleton code.

Don't forget the BUILD script and README files.


ABCDEFGHIJKLMNOPQ
17


Assignment 3: Standard I/O Library
Original author: Munehiro Fukuda

Revisions 2019: Morris Bernstein

As we have seen in Lab 3, the operating system calls open, close, read, write, llseek, etc. provide an effective interface to the filesystem, but have significant limitations. Performance and convenience can be dramatically improved using a higher-level userland library that provides buffering and data-formatting. Furthermore, programs that use the language-defined standard library are more likely to be portable across operating systems.

The standard I/O library of the C language is available to any C or C++ program that includes the stdio.h (cstdio in C++) header file. Since C predates the object-oriented paradigm, the FILE* object is passed in as the first argument to the various functions that implement file operations, but it is fundamentally an operation on an object.

For this assignment, you will implement a class-based version of the C standard I/O library. The constructor will open the file, and the destructor will close the file.

Since constructors and destructors don't return values, we have to alter the semantics slightly: if an error occurs, throw an exception.

Implement the following methods using only the underlying system calls. See the corresponding man pages. Note that the file argument is implicit in the method call, so we must alter the function signature slightly.
ferror
feof
fflush
fputc
fgetc
fgets
fputs
fseek
Do not use the C++ standard template library, C++ strings library, C standard I/O library or C standard strings functions. You may use malloc to allocate the buffer.

Behavior should be predictable even for files opened in read/write mode. For example, if you read ABC from the file, write XYZ, and then read GHI, the file should end up containing ABCXYZGHI regardless of the buffering mode. Similarly, writing ABCDEFGHI, repositioning the file pointer to the beginning of the file ("rewinding") and writing XYZ should leave XYZDEFGHI in the file regardless of the buffering mode.

Your test program should verify that writing to a read-only file is an error; reading from a write-only file is an error; and that the the code correctly handles the switch between reading and writing in read/write mode.

Your implementation need not worry about thread-safety.

For the purposes of the assignment you only need to implement the default FULL_BUFFER mode. setvbuf is unsupported.

"a" and "a+" modes have complicated semantics and need not be implemented.

You may crash the program if any unsupported feature is called. See undefined behavior.

An application using your library should #include "file.h" and link with file.o (produced by compiling file.cc with the -c flag. Simulate this by putting your implementation and test program in separate directories (use the -I flag when compiling your test program).

Repeat the benchmarking of Lab 3 for your implementation. This means you will be creating two separate executable programs that use your I/O library.

Skeletons have been provided: file-skel.h and file-skel.cc. You may also reuse or cannibalize any of the work that you did for Lab 3.

For reference, a simplified version of fprintf has been provided in the skeleton code.

Don't forget the BUILD script and README files.


ABCDEFGHIJKLMNOPQ
18


Assignment 3: Standard I/O Library
Original author: Munehiro Fukuda

Revisions 2019: Morris Bernstein

As we have seen in Lab 3, the operating system calls open, close, read, write, llseek, etc. provide an effective interface to the filesystem, but have significant limitations. Performance and convenience can be dramatically improved using a higher-level userland library that provides buffering and data-formatting. Furthermore, programs that use the language-defined standard library are more likely to be portable across operating systems.

The standard I/O library of the C language is available to any C or C++ program that includes the stdio.h (cstdio in C++) header file. Since C predates the object-oriented paradigm, the FILE* object is passed in as the first argument to the various functions that implement file operations, but it is fundamentally an operation on an object.

For this assignment, you will implement a class-based version of the C standard I/O library. The constructor will open the file, and the destructor will close the file.

Since constructors and destructors don't return values, we have to alter the semantics slightly: if an error occurs, throw an exception.

Implement the following methods using only the underlying system calls. See the corresponding man pages. Note that the file argument is implicit in the method call, so we must alter the function signature slightly.
ferror
feof
fflush
fputc
fgetc
fgets
fputs
fseek
Do not use the C++ standard template library, C++ strings library, C standard I/O library or C standard strings functions. You may use malloc to allocate the buffer.

Behavior should be predictable even for files opened in read/write mode. For example, if you read ABC from the file, write XYZ, and then read GHI, the file should end up containing ABCXYZGHI regardless of the buffering mode. Similarly, writing ABCDEFGHI, repositioning the file pointer to the beginning of the file ("rewinding") and writing XYZ should leave XYZDEFGHI in the file regardless of the buffering mode.

Your test program should verify that writing to a read-only file is an error; reading from a write-only file is an error; and that the the code correctly handles the switch between reading and writing in read/write mode.

Your implementation need not worry about thread-safety.

For the purposes of the assignment you only need to implement the default FULL_BUFFER mode. setvbuf is unsupported.

"a" and "a+" modes have complicated semantics and need not be implemented.

You may crash the program if any unsupported feature is called. See undefined behavior.

An application using your library should #include "file.h" and link with file.o (produced by compiling file.cc with the -c flag. Simulate this by putting your implementation and test program in separate directories (use the -I flag when compiling your test program).

Repeat the benchmarking of Lab 3 for your implementation. This means you will be creating two separate executable programs that use your I/O library.

Skeletons have been provided: file-skel.h and file-skel.cc. You may also reuse or cannibalize any of the work that you did for Lab 3.

For reference, a simplified version of fprintf has been provided in the skeleton code.

Don't forget the BUILD script and README files.


ABCDEFGHIJKLMNOPQ
19


Assignment 3: Standard I/O Library
Original author: Munehiro Fukuda

Revisions 2019: Morris Bernstein

As we have seen in Lab 3, the operating system calls open, close, read, write, llseek, etc. provide an effective interface to the filesystem, but have significant limitations. Performance and convenience can be dramatically improved using a higher-level userland library that provides buffering and data-formatting. Furthermore, programs that use the language-defined standard library are more likely to be portable across operating systems.

The standard I/O library of the C language is available to any C or C++ program that includes the stdio.h (cstdio in C++) header file. Since C predates the object-oriented paradigm, the FILE* object is passed in as the first argument to the various functions that implement file operations, but it is fundamentally an operation on an object.

For this assignment, you will implement a class-based version of the C standard I/O library. The constructor will open the file, and the destructor will close the file.

Since constructors and destructors don't return values, we have to alter the semantics slightly: if an error occurs, throw an exception.

Implement the following methods using only the underlying system calls. See the corresponding man pages. Note that the file argument is implicit in the method call, so we must alter the function signature slightly.
ferror
feof
fflush
fputc
fgetc
fgets
fputs
fseek
Do not use the C++ standard template library, C++ strings library, C standard I/O library or C standard strings functions. You may use malloc to allocate the buffer.

Behavior should be predictable even for files opened in read/write mode. For example, if you read ABC from the file, write XYZ, and then read GHI, the file should end up containing ABCXYZGHI regardless of the buffering mode. Similarly, writing ABCDEFGHI, repositioning the file pointer to the beginning of the file ("rewinding") and writing XYZ should leave XYZDEFGHI in the file regardless of the buffering mode.

Your test program should verify that writing to a read-only file is an error; reading from a write-only file is an error; and that the the code correctly handles the switch between reading and writing in read/write mode.

Your implementation need not worry about thread-safety.

For the purposes of the assignment you only need to implement the default FULL_BUFFER mode. setvbuf is unsupported.

"a" and "a+" modes have complicated semantics and need not be implemented.

You may crash the program if any unsupported feature is called. See undefined behavior.

An application using your library should #include "file.h" and link with file.o (produced by compiling file.cc with the -c flag. Simulate this by putting your implementation and test program in separate directories (use the -I flag when compiling your test program).

Repeat the benchmarking of Lab 3 for your implementation. This means you will be creating two separate executable programs that use your I/O library.

Skeletons have been provided: file-skel.h and file-skel.cc. You may also reuse or cannibalize any of the work that you did for Lab 3.

For reference, a simplified version of fprintf has been provided in the skeleton code.

Don't forget the BUILD script and README files.


ABCDEFGHIJKLMNOPQ
20


Assignment 3: Standard I/O Library
Original author: Munehiro Fukuda

Revisions 2019: Morris Bernstein

As we have seen in Lab 3, the operating system calls open, close, read, write, llseek, etc. provide an effective interface to the filesystem, but have significant limitations. Performance and convenience can be dramatically improved using a higher-level userland library that provides buffering and data-formatting. Furthermore, programs that use the language-defined standard library are more likely to be portable across operating systems.

The standard I/O library of the C language is available to any C or C++ program that includes the stdio.h (cstdio in C++) header file. Since C predates the object-oriented paradigm, the FILE* object is passed in as the first argument to the various functions that implement file operations, but it is fundamentally an operation on an object.

For this assignment, you will implement a class-based version of the C standard I/O library. The constructor will open the file, and the destructor will close the file.

Since constructors and destructors don't return values, we have to alter the semantics slightly: if an error occurs, throw an exception.

Implement 
 ********************************************* 



 ******* The 12 time fread and read 12288 bits ********
the following methods using only the underlying system calls. See the corresponding man pages. Note that the file argument is implicit in the method call, so we must alter the function signature slightly.
ferror
feof
fflush
fputc
fgetc
fgets
fputs
fseek
Do not use the C++ standard template library, C++ strings library, C standard I/O library or C standard strings functions. You may use malloc to allocate the buffer.

Behavior should be predictable even for files opened in read/write mode. For example, if you read ABC from the file, write XYZ, and then read GHI, the file should end up containing ABCXYZGHI regardless of the buffering mode. Similarly, writing ABCDEFGHI, repositioning the file pointer to the beginning of the file ("rewinding") and writing XYZ should leave XYZDEFGHI in the file regardless of the buffering mode.

Your test program should verify that writing to a read-only file is an error; reading from a write-only file is an error; and that the the code correctly handles the switch between reading and writing in read/write mode.

Your implementation need not worry about thread-safety.

For the purposes of the assignment you only need to implement the default FULL_BUFFER mode. setvbuf is unsupported.

"a" and "a+" modes have complicated semantics and need not be implemented.

You may crash the program if any unsupported feature is called. See undefined behavior.

An application using your library should #include "file.h" and link with file.o (produced by compiling file.cc with the -c flag. Simulate this by putting your implementation and test program in separate directories (use the -I flag when compiling your test program).

Repeat the benchmarking of Lab 3 for your implementation. This means you will be creating two separate executable programs that use your I/O library.

Skeletons have been provided: file-skel.h and file-skel.cc. You may also reuse or cannibalize any of the work that you did for Lab 3.

For reference, a simplified version of fprintf has been provided in the skeleton code.

Don't forget the BUILD script and README files.


ABCDEFGHIJKLMNOPQ
21


Assignment 3: Standard I/O Library
Original author: Munehiro Fukuda

Revisions 2019: Morris Bernstein

As we have seen in Lab 3, the operating system calls open, close, read, write, llseek, etc. provide an effective interface to the filesystem, but have significant limitations. Performance and convenience can be dramatically improved using a higher-level userland library that provides buffering and data-formatting. Furthermore, programs that use the language-defined standard library are more likely to be portable across operating systems.

The standard I/O library of the C language is available to any C or C++ program that includes the stdio.h (cstdio in C++) header file. Since C predates the object-oriented paradigm, the FILE* object is passed in as the first argument to the various functions that implement file operations, but it is fundamentally an operation on an object.

For this assignment, you will implement a class-based version of the C standard I/O library. The constructor will open the file, and the destructor will close the file.

Since constructors and destructors don't return values, we have to alter the semantics slightly: if an error occurs, throw an exception.

Implement the following methods using only the underlying system calls. See the corresponding man pages. Note that the file argument is implicit in the method call, so we must alter the function signature slightly.
ferror
feof
fflush
fputc
fgetc
fgets
fputs
fseek
Do not use the C++ standard template library, C++ strings library, C standard I/O library or C standard strings functions. You may use malloc to allocate the buffer.

Behavior should be predictable even for files opened in read/write mode. For example, if you read ABC from the file, write XYZ, and then read GHI, the file should end up containing ABCXYZGHI regardless of the buffering mode. Similarly, writing ABCDEFGHI, repositioning the file pointer to the beginning of the file ("rewinding") and writing XYZ should leave XYZDEFGHI in the file regardless of the buffering mode.

Your test program should verify that writing to a read-only file is an error; reading from a write-only file is an error; and that the the code correctly handles the switch between reading and writing in read/write mode.

Your implementation need not worry about thread-safety.

For the purposes of the assignment you only need to implement the default FULL_BUFFER mode. setvbuf is unsupported.

"a" and "a+" modes have complicated semantics and need not be implemented.

You may crash the program if any unsupported feature is called. See undefined behavior.

An application using your library should #include "file.h" and link with file.o (produced by compiling file.cc with the -c flag. Simulate this by putting your implementation and test program in separate directories (use the -I flag when compiling your test program).

Repeat the benchmarking of Lab 3 for your implementation. This means you will be creating two separate executable programs that use your I/O library.

Skeletons have been provided: file-skel.h and file-skel.cc. You may also reuse or cannibalize any of the work that you did for Lab 3.

For reference, a simplified version of fprintf has been provided in the skeleton code.

Don't forget the BUILD script and README files.


ABCDEFGHIJKLMNOPQ
22


Assignment 3: Standard I/O Library
Original author: Munehiro Fukuda

Revisions 2019: Morris Bernstein

As we have seen in Lab 3, the operating system calls open, close, read, write, llseek, etc. provide an effective interface to the filesystem, but have significant limitations. Performance and convenience can be dramatically improved using a higher-level userland library that provides buffering and data-formatting. Furthermore, programs that use the language-defined standard library are more likely to be portable across operating systems.

The standard I/O library of the C language is available to any C or C++ program that includes the stdio.h (cstdio in C++) header file. Since C predates the object-oriented paradigm, the FILE* object is passed in as the first argument to the various functions that implement file operations, but it is fundamentally an operation on an object.

For this assignment, you will implement a class-based version of the C standard I/O library. The constructor will open the file, and the destructor will close the file.

Since constructors and destructors don't return values, we have to alter the semantics slightly: if an error occurs, throw an exception.

Implement the following methods using only the underlying system calls. See the corresponding man pages. Note that the file argument is implicit in the method call, so we must alter the function signature slightly.
ferror
feof
fflush
fputc
fgetc
fgets
fputs
fseek
Do not use the C++ standard template library, C++ strings library, C standard I/O library or C standard strings functions. You may use malloc to allocate the buffer.

Behavior should be predictable even for files opened in read/write mode. For example, if you read ABC from the file, write XYZ, and then read GHI, the file should end up containing ABCXYZGHI regardless of the buffering mode. Similarly, writing ABCDEFGHI, repositioning the file pointer to the beginning of the file ("rewinding") and writing XYZ should leave XYZDEFGHI in the file regardless of the buffering mode.

Your test program should verify that writing to a read-only file is an error; reading from a write-only file is an error; and that the the code correctly handles the switch between reading and writing in read/write mode.

Your implementation need not worry about thread-safety.

For the purposes of the assignment you only need to implement the default FULL_BUFFER mode. setvbuf is unsupported.

"a" and "a+" modes have complicated semantics and need not be implemented.

You may crash the program if any unsupported feature is called. See undefined behavior.

An application using your library should #include "file.h" and link with file.o (produced by compiling file.cc with the -c flag. Simulate this by putting your implementation and test program in separate directories (use the -I flag when compiling your test program).

Repeat the benchmarking of Lab 3 for your implementation. This means you will be creating two separate executable programs that use your I/O library.

Skeletons have been provided: file-skel.h and file-skel.cc. You may also reuse or cannibalize any of the work that you did for Lab 3.

For reference, a simplified version of fprintf has been provided in the skeleton code.

Don't forget the BUILD script and README files.


ABCDEFGHIJKLMNOPQ
23


Assignment 3: Standard I/O Library
Original author: Munehiro Fukuda

Revisions 2019: Morris Bernstein

As we have seen in Lab 3, the operating system calls open, close, read, write, llseek, etc. provide an effective interface to the filesystem, but have significant limitations. Performance and convenience can be dramatically improved using a higher-level userland library that provides buffering and data-formatting. Furthermore, programs that use the language-defined standard library are more likely to be portable across operating systems.

The standard I/O library of the C language is available to any C or C++ program that includes the stdio.h (cstdio in C++) header file. Since C predates the object-oriented paradigm, the FILE* object is passed in as the first argument to the various functions that implement file operations, but it is fundamentally an operation on an object.

For this assignment, you will implement a class-based version of the C standard I/O library. The constructor will open the file, and the destructor will close the file.

Since constructors and destructors don't return values, we have to alter the semantics slightly: if an error occurs, throw an exception.

Implement the following methods using only the underlying system calls. See the corresponding man pages. Note that the file argument is implicit in the method call, so we must alter the function signature slightly.
ferror
feof
fflush
fputc
fgetc
fgets
fputs
fseek
Do not use the C++ standard template library, C++ strings library, C standard I/O library or C standard strings functions. You may use malloc to allocate the buffer.

Behavior should be predictable even for files opened in read/write mode. For example, if you read ABC from the file, write XYZ, and then read GHI, the file should end up containing ABCXYZGHI regardless of the buffering mode. Similarly, writing ABCDEFGHI, repositioning the file pointer to the beginning of the file ("rewinding") and writing XYZ should leave XYZDEFGHI in the file regardless of the buffering mode.

Your test program should verify that writing to a read-only file is an error; reading from a write-only file is an error; and that the the code correctly handles the switch between reading and writing in read/write mode.

Your implementation need not worry about thread-safety.

For the purposes of the assignment you only need to implement the default FULL_BUFFER mode. setvbuf is unsupported.

"a" and "a+" modes have complicated semantics and need not be implemented.

You may crash the program if any unsupported feature is called. See undefined behavior.

An application using your library should #include "file.h" and link with file.o (produced by compiling file.cc with the -c flag. Simulate this by putting your implementation and test program in separate directories (use the -I flag when compiling your test program).

Repeat the benchmarking of Lab 3 for your implementation. This means you will be creating two separate executable programs that use your I/O library.

Skeletons have been provided: file-skel.h and file-skel.cc. You may also reuse or cannibalize any of the work that you did for Lab 3.

For reference, a simplified version of fprintf has been provided in the skeleton code.

Don't forget the BUILD script and README files.


ABCDEFGHIJKLMNOPQ
24


Assignment 3: Standard I/O Library
Original author: Munehiro Fukuda

Revisions 2019: Morris Bernstein

As we have seen in Lab 3, the operating system calls open, close, read, write, llseek, etc. provide an effective int
 ********************************************* 



 ******* The 13 time fread and read 13312 bits ********
erface to the filesystem, but have significant limitations. Performance and convenience can be dramatically improved using a higher-level userland library that provides buffering and data-formatting. Furthermore, programs that use the language-defined standard library are more likely to be portable across operating systems.

The standard I/O library of the C language is available to any C or C++ program that includes the stdio.h (cstdio in C++) header file. Since C predates the object-oriented paradigm, the FILE* object is passed in as the first argument to the various functions that implement file operations, but it is fundamentally an operation on an object.

For this assignment, you will implement a class-based version of the C standard I/O library. The constructor will open the file, and the destructor will close the file.

Since constructors and destructors don't return values, we have to alter the semantics slightly: if an error occurs, throw an exception.

Implement the following methods using only the underlying system calls. See the corresponding man pages. Note that the file argument is implicit in the method call, so we must alter the function signature slightly.
ferror
feof
fflush
fputc
fgetc
fgets
fputs
fseek
Do not use the C++ standard template library, C++ strings library, C standard I/O library or C standard strings functions. You may use malloc to allocate the buffer.

Behavior should be predictable even for files opened in read/write mode. For example, if you read ABC from the file, write XYZ, and then read GHI, the file should end up containing ABCXYZGHI regardless of the buffering mode. Similarly, writing ABCDEFGHI, repositioning the file pointer to the beginning of the file ("rewinding") and writing XYZ should leave XYZDEFGHI in the file regardless of the buffering mode.

Your test program should verify that writing to a read-only file is an error; reading from a write-only file is an error; and that the the code correctly handles the switch between reading and writing in read/write mode.

Your implementation need not worry about thread-safety.

For the purposes of the assignment you only need to implement the default FULL_BUFFER mode. setvbuf is unsupported.

"a" and "a+" modes have complicated semantics and need not be implemented.

You may crash the program if any unsupported feature is called. See undefined behavior.

An application using your library should #include "file.h" and link with file.o (produced by compiling file.cc with the -c flag. Simulate this by putting your implementation and test program in separate directories (use the -I flag when compiling your test program).

Repeat the benchmarking of Lab 3 for your implementation. This means you will be creating two separate executable programs that use your I/O library.

Skeletons have been provided: file-skel.h and file-skel.cc. You may also reuse or cannibalize any of the work that you did for Lab 3.

For reference, a simplified version of fprintf has been provided in the skeleton code.

Don't forget the BUILD script and README files.


ABCDEFGHIJKLMNOPQ
25


Assignment 3: Standard I/O Library
Original author: Munehiro Fukuda

Revisions 2019: Morris Bernstein

As we have seen in Lab 3, the operating system calls open, close, read, write, llseek, etc. provide an effective interface to the filesystem, but have significant limitations. Performance and convenience can be dramatically improved using a higher-level userland library that provides buffering and data-formatting. Furthermore, programs that use the language-defined standard library are more likely to be portable across operating systems.

The standard I/O library of the C language is available to any C or C++ program that includes the stdio.h (cstdio in C++) header file. Since C predates the object-oriented paradigm, the FILE* object is passed in as the first argument to the various functions that implement file operations, but it is fundamentally an operation on an object.

For this assignment, you will implement a class-based version of the C standard I/O library. The constructor will open the file, and the destructor will close the file.

Since constructors and destructors don't return values, we have to alter the semantics slightly: if an error occurs, throw an exception.

Implement the following methods using only the underlying system calls. See the corresponding man pages. Note that the file argument is implicit in the method call, so we must alter the function signature slightly.
ferror
feof
fflush
fputc
fgetc
fgets
fputs
fseek
Do not use the C++ standard template library, C++ strings library, C standard I/O library or C standard strings functions. You may use malloc to allocate the buffer.

Behavior should be predictable even for files opened in read/write mode. For example, if you read ABC from the file, write XYZ, and then read GHI, the file should end up containing ABCXYZGHI regardless of the buffering mode. Similarly, writing ABCDEFGHI, repositioning the file pointer to the beginning of the file ("rewinding") and writing XYZ should leave XYZDEFGHI in the file regardless of the buffering mode.

Your test program should verify that writing to a read-only file is an error; reading from a write-only file is an error; and that the the code correctly handles the switch between reading and writing in read/write mode.

Your implementation need not worry about thread-safety.

For the purposes of the assignment you only need to implement the default FULL_BUFFER mode. setvbuf is unsupported.

"a" and "a+" modes have complicated semantics and need not be implemented.

You may crash the program if any unsupported feature is called. See undefined behavior.

An application using your library should #include "file.h" and link with file.o (produced by compiling file.cc with the -c flag. Simulate this by putting your implementation and test program in separate directories (use the -I flag when compiling your test program).

Repeat the benchmarking of Lab 3 for your implementation. This means you will be creating two separate executable programs that use your I/O library.

Skeletons have been provided: file-skel.h and file-skel.cc. You may also reuse or cannibalize any of the work that you did for Lab 3.

For reference, a simplified version of fprintf has been provided in the skeleton code.

Don't forget the BUILD script and README files.


ABCDEFGHIJKLMNOPQ
26


Assignment 3: Standard I/O Library
Original author: Munehiro Fukuda

Revisions 2019: Morris Bernstein

As we have seen in Lab 3, the operating system calls open, close, read, write, llseek, etc. provide an effective interface to the filesystem, but have significant limitations. Performance and convenience can be dramatically improved using a higher-level userland library that provides buffering and data-formatting. Furthermore, programs that use the language-defined standard library are more likely to be portable across operating systems.

The standard I/O library of the C language is available to any C or C++ program that includes the stdio.h (cstdio in C++) header file. Since C predates the object-oriented paradigm, the FILE* object is passed in as the first argument to the various functions that implement file operations, but it is fundamentally an operation on an object.

For this assignment, you will implement a class-based version of the C standard I/O library. The constructor will open the file, and the destructor will close the file.

Since constructors and destructors don't return values, we have to alter the semantics slightly: if an error occurs, throw an exception.

Implement the following methods using only the underlying system calls. See the corresponding man pages. Note that the file argument is implicit in the method call, so we must alter the function signature slightly.
ferror
feof
fflush
fputc
fgetc
fgets
fputs
fseek
Do not use the C++ standard template library, C++ strings library, C standard I/O library or C standard strings functions. You may use malloc to allocate the buffer.

Behavior should be predictable even for files opened in read/write mode. For example, if you read ABC from the file, write XYZ, and then read GHI, the file should end up containing ABCXYZGHI regardless of the buffering mode. Similarly, writing ABCDEFGHI, repositioning the file pointer to the beginning of the file ("rewinding") and writing XYZ should leave XYZDEFGHI in the file regardless of the buffering mode.

Your test program should verify that writing to a read-only file is an error; reading from a write-only file is an error; and that the the code correctly handles the switch between reading and writing in read/write mode.

Your implementation need not worry about thread-safety.

For the purposes of the assignment you only need to implement the default FULL_BUFFER mode. setvbuf is unsupported.

"a" and "a+" modes have complicated semantics and need not be implemented.

You may crash the program if any unsupported feature is called. See undefined behavior.

An application using your library should #include "file.h" and link with file.o (produced by compiling file.cc with the -c flag. Simulate this by putting your implementation and test program in separate directories (use the -I flag when compiling your test program).

Repeat the benchmarking of Lab 3 for your implementation. This means you will be creating two separate executable programs that use your I/O library.

Skeletons have been provided: file-skel.h and file-skel.cc. You may also reuse or cannibalize any of the work that you did for Lab 3.

For reference, a simplified version of fprintf has been provided in the skeleton code.

Don't forget the BUILD script and README files.


ABCDEFGHIJKLMNOPQ
27


Assignment 3: Standard I/O Library
Original author: Munehiro Fukuda

Revisions 2019: Morris Bernstein

As we have seen in Lab 3, the operating system calls open, close, read, write, llseek, etc. provide an effective interface to the filesystem, but have significant limitations. Performance and convenience can be dramatically improved using a higher-level userland library that provides buffering and data-formatting. Furthermore, programs that use the language-defined standard library are more likely to be portable across operating systems.

The standard I/O library of the C language is available to any C or C++ program that includes the stdio.h (cstdio in C++) header file. Since C predates the object-oriented paradigm, the FILE* object is passed in as the first argument to the various functions that implement file operations, but it is fundamentally an operation on an object.

For this assignment, you will implement a class-based version of the C standard I/O library. The constructor will open the file, and the destructor will close the file.

Since constructors and destructors don't return values, we have to alter the semantics slightly: if an error occurs, throw an exception.

Implement the following methods using only the underlying system calls. See the corresponding man pages. Note that the file argument is implicit in the method call, so we must alter the function signature slightly.
ferror
feof
fflush
fputc
fgetc
fgets
fputs
fseek
Do not use the C++ standard template library, C++ strings library, C standard I/O library or C standard strings functions. You may use malloc to allocate the buffer.

Behavior should be predictable even for files opened in read/write mode. For example, if you read ABC from the file, write XYZ, and then read GHI, the file should end up containing ABCXYZGHI regardless of the buffering mode. Similarly, writing ABCDEFGHI, repositioning the file pointer to the beginning of the file ("rewinding") and writing XYZ should leave XYZDEFGHI in the file regardless of the buffering mode.

Your test program should verify that writing to a read-only file is an error; reading from a write-only file is an error; and that the the code correctly handles the switch between reading and writing in read/write mode.

Your implementation need not worry about thread-safety.

For the purposes of the assignment you only need to implement the default FULL_BUFFER mode. setvbuf is unsupported.

"a" and "a+" modes have complicated semantics and need not be implemented.

You may crash the program if any unsupported feature is called. See undefined behavior.

An application using your library should #include "file.h" and link with file.o (produced by compiling file.cc with the -c flag. Simulate this by putting your implementation and test program in separate directories (use the -I flag when compiling your test program).

Repeat the benchmarking of Lab 3 for your implementation. This means you will be creating two separate executable programs that use your I/O library.

Skeletons have been provided: file-skel.h and file-skel.cc. You may also reuse or cannibalize any of the work that you did for Lab 3.

For reference, a simplified version of fprintf has been provided in the skeleton code.

Don't forget the BUILD script and README files.


ABCDEFGHIJKLMNOPQ
28


Assignment 3: Standard I/O Library
Original author: Munehiro Fukuda

Revisions 2019: Morris Bernstein

As we have seen in Lab 3, the operating system calls open, close, read, write, llseek, etc. provide an effective interface to the filesystem, but have s
 ********************************************* 



 ******* The 14 time fread and read 14336 bits ********
ignificant limitations. Performance and convenience can be dramatically improved using a higher-level userland library that provides buffering and data-formatting. Furthermore, programs that use the language-defined standard library are more likely to be portable across operating systems.

The standard I/O library of the C language is available to any C or C++ program that includes the stdio.h (cstdio in C++) header file. Since C predates the object-oriented paradigm, the FILE* object is passed in as the first argument to the various functions that implement file operations, but it is fundamentally an operation on an object.

For this assignment, you will implement a class-based version of the C standard I/O library. The constructor will open the file, and the destructor will close the file.

Since constructors and destructors don't return values, we have to alter the semantics slightly: if an error occurs, throw an exception.

Implement the following methods using only the underlying system calls. See the corresponding man pages. Note that the file argument is implicit in the method call, so we must alter the function signature slightly.
ferror
feof
fflush
fputc
fgetc
fgets
fputs
fseek
Do not use the C++ standard template library, C++ strings library, C standard I/O library or C standard strings functions. You may use malloc to allocate the buffer.

Behavior should be predictable even for files opened in read/write mode. For example, if you read ABC from the file, write XYZ, and then read GHI, the file should end up containing ABCXYZGHI regardless of the buffering mode. Similarly, writing ABCDEFGHI, repositioning the file pointer to the beginning of the file ("rewinding") and writing XYZ should leave XYZDEFGHI in the file regardless of the buffering mode.

Your test program should verify that writing to a read-only file is an error; reading from a write-only file is an error; and that the the code correctly handles the switch between reading and writing in read/write mode.

Your implementation need not worry about thread-safety.

For the purposes of the assignment you only need to implement the default FULL_BUFFER mode. setvbuf is unsupported.

"a" and "a+" modes have complicated semantics and need not be implemented.

You may crash the program if any unsupported feature is called. See undefined behavior.

An application using your library should #include "file.h" and link with file.o (produced by compiling file.cc with the -c flag. Simulate this by putting your implementation and test program in separate directories (use the -I flag when compiling your test program).

Repeat the benchmarking of Lab 3 for your implementation. This means you will be creating two separate executable programs that use your I/O library.

Skeletons have been provided: file-skel.h and file-skel.cc. You may also reuse or cannibalize any of the work that you did for Lab 3.

For reference, a simplified version of fprintf has been provided in the skeleton code.

Don't forget the BUILD script and README files.


ABCDEFGHIJKLMNOPQ
29


Assignment 3: Standard I/O Library
Original author: Munehiro Fukuda

Revisions 2019: Morris Bernstein

As we have seen in Lab 3, the operating system calls open, close, read, write, llseek, etc. provide an effective interface to the filesystem, but have significant limitations. Performance and convenience can be dramatically improved using a higher-level userland library that provides buffering and data-formatting. Furthermore, programs that use the language-defined standard library are more likely to be portable across operating systems.

The standard I/O library of the C language is available to any C or C++ program that includes the stdio.h (cstdio in C++) header file. Since C predates the object-oriented paradigm, the FILE* object is passed in as the first argument to the various functions that implement file operations, but it is fundamentally an operation on an object.

For this assignment, you will implement a class-based version of the C standard I/O library. The constructor will open the file, and the destructor will close the file.

Since constructors and destructors don't return values, we have to alter the semantics slightly: if an error occurs, throw an exception.

Implement the following methods using only the underlying system calls. See the corresponding man pages. Note that the file argument is implicit in the method call, so we must alter the function signature slightly.
ferror
feof
fflush
fputc
fgetc
fgets
fputs
fseek
Do not use the C++ standard template library, C++ strings library, C standard I/O library or C standard strings functions. You may use malloc to allocate the buffer.

Behavior should be predictable even for files opened in read/write mode. For example, if you read ABC from the file, write XYZ, and then read GHI, the file should end up containing ABCXYZGHI regardless of the buffering mode. Similarly, writing ABCDEFGHI, repositioning the file pointer to the beginning of the file ("rewinding") and writing XYZ should leave XYZDEFGHI in the file regardless of the buffering mode.

Your test program should verify that writing to a read-only file is an error; reading from a write-only file is an error; and that the the code correctly handles the switch between reading and writing in read/write mode.

Your implementation need not worry about thread-safety.

For the purposes of the assignment you only need to implement the default FULL_BUFFER mode. setvbuf is unsupported.

"a" and "a+" modes have complicated semantics and need not be implemented.

You may crash the program if any unsupported feature is called. See undefined behavior.

An application using your library should #include "file.h" and link with file.o (produced by compiling file.cc with the -c flag. Simulate this by putting your implementation and test program in separate directories (use the -I flag when compiling your test program).

Repeat the benchmarking of Lab 3 for your implementation. This means you will be creating two separate executable programs that use your I/O library.

Skeletons have been provided: file-skel.h and file-skel.cc. You may also reuse or cannibalize any of the work that you did for Lab 3.

For reference, a simplified version of fprintf has been provided in the skeleton code.

Don't forget the BUILD script and README files.


ABCDEFGHIJKLMNOPQ
30


Assignment 3: Standard I/O Library
Original author: Munehiro Fukuda

Revisions 2019: Morris Bernstein

As we have seen in Lab 3, the operating system calls open, close, read, write, llseek, etc. provide an effective interface to the filesystem, but have significant limitations. Performance and convenience can be dramatically improved using a higher-level userland library that provides buffering and data-formatting. Furthermore, programs that use the language-defined standard library are more likely to be portable across operating systems.

The standard I/O library of the C language is available to any C or C++ program that includes the stdio.h (cstdio in C++) header file. Since C predates the object-oriented paradigm, the FILE* object is passed in as the first argument to the various functions that implement file operations, but it is fundamentally an operation on an object.

For this assignment, you will implement a class-based version of the C standard I/O library. The constructor will open the file, and the destructor will close the file.

Since constructors and destructors don't return values, we have to alter the semantics slightly: if an error occurs, throw an exception.

Implement the following methods using only the underlying system calls. See the corresponding man pages. Note that the file argument is implicit in the method call, so we must alter the function signature slightly.
ferror
feof
fflush
fputc
fgetc
fgets
fputs
fseek
Do not use the C++ standard template library, C++ strings library, C standard I/O library or C standard strings functions. You may use malloc to allocate the buffer.

Behavior should be predictable even for files opened in read/write mode. For example, if you read ABC from the file, write XYZ, and then read GHI, the file should end up containing ABCXYZGHI regardless of the buffering mode. Similarly, writing ABCDEFGHI, repositioning the file pointer to the beginning of the file ("rewinding") and writing XYZ should leave XYZDEFGHI in the file regardless of the buffering mode.

Your test program should verify that writing to a read-only file is an error; reading from a write-only file is an error; and that the the code correctly handles the switch between reading and writing in read/write mode.

Your implementation need not worry about thread-safety.

For the purposes of the assignment you only need to implement the default FULL_BUFFER mode. setvbuf is unsupported.

"a" and "a+" modes have complicated semantics and need not be implemented.

You may crash the program if any unsupported feature is called. See undefined behavior.

An application using your library should #include "file.h" and link with file.o (produced by compiling file.cc with the -c flag. Simulate this by putting your implementation and test program in separate directories (use the -I flag when compiling your test program).

Repeat the benchmarking of Lab 3 for your implementation. This means you will be creating two separate executable programs that use your I/O library.

Skeletons have been provided: file-skel.h and file-skel.cc. You may also reuse or cannibalize any of the work that you did for Lab 3.

For reference, a simplified version of fprintf has been provided in the skeleton code.

Don't forget the BUILD script and README files.



ABCDEFGHIJKLMNOPQ
31


Assignment 3: Standard I/O Library
Original author: Munehiro Fukuda

Revisions 2019: Morris Bernstein

As we have seen in Lab 3, the operating system calls open, close, read, write, llseek, etc. provide an effective interface to the filesystem, but have significant limitations. Performance and convenience can be dramatically improved using a higher-level userland library that provides buffering and data-formatting. Furthermore, programs that use the language-defined standard library are more likely to be portable across operating systems.

The standard I/O library of the C language is available to any C or C++ program that includes the stdio.h (cstdio in C++) header file. Since C predates the object-oriented paradigm, the FILE* object is passed in as the first argument to the various functions that implement file operations, but it is fundamentally an operation on an object.

For this assignment, you will implement a class-based version of the C standard I/O library. The constructor will open the file, and the destructor will close the file.

Since constructors and destructors don't return values, we have to alter the semantics slightly: if an error occurs, throw an exception.

Implement the following methods using only the underlying system calls. See the corresponding man pages. Note that the file argument is implicit in the method call, so we must alter the function signature slightly.
ferror
feof
fflush
fputc
fgetc
fgets
fputs
fseek
Do not use the C++ standard template library, C++ strings library, C standard I/O library or C standard strings functions. You may use malloc to allocate the buffer.

Behavior should be predictable even for files opened in read/write mode. For example, if you read ABC from the file, write XYZ, and then read GHI, the file should end up containing ABCXYZGHI regardless of the buffering mode. Similarly, writing ABCDEFGHI, repositioning the file pointer to the beginning of the file ("rewinding") and writing XYZ should leave XYZDEFGHI in the file regardless of the buffering mode.

Your test program should verify that writing to a read-only file is an error; reading from a write-only file is an error; and that the the code correctly handles the switch between reading and writing in read/write mode.

Your implementation need not worry about thread-safety.

For the purposes of the assignment you only need to implement the default FULL_BUFFER mode. setvbuf is unsupported.

"a" and "a+" modes have complicated semantics and need not be implemented.

You may crash the program if any unsupported feature is called. See undefined behavior.

An application using your library should #include "file.h" and link with file.o (produced by compiling file.cc with the -c flag. Simulate this by putting your implementation and test program in separate directories (use the -I flag when compiling your test program).

Repeat the benchmarking of Lab 3 for your implementation. This means you will be creating two separate executable programs that use your I/O library.

Skeletons have been provided: file-skel.h and file-skel.cc. You may also reuse or cannibalize any of the work that you did for Lab 3.

For reference, a simplified version of fprintf has been provided in the skeleton code.

Don't forget the BUILD script and README files.


ABCDEFGHIJKLMNOPQ
32


Assignment 3: Standard I/O Library
Original author: Munehiro Fukuda

Revisions 2019: Morris Bernstein

As we have seen in Lab 3, the operating system calls open, close, read, write, llseek, etc. provide an effective interface to the filesystem, but have significant limitations. Performance and convenience can be dramatically improved using a higher-level userland library that provides buffering and data-formatting. Furthermore, programs that use the language-defined standard library are more likely to be portable across operating systems.

The standard I/O library of the C language is available to any C or C++ program that includes the stdio.h (cstdio in C++) header file. Since C predates the object-oriented paradigm, the FILE* object is passed in as the first argument to the various functions that implement file operations, but it is fundamentally an operation on an object.

For this assignment, you will implement a class-based version of the C standard I/O library. The constructor will open the file, and the destructor will close the file.

Since constructors and destructors don't return values, we have to alter the semantics slightly: if an error occurs, throw an exception.

Implement the following methods using only the underlying system calls. See the corresponding man pages. Note that th
 ********************************************* 



 ******* The 15 time fread and read 15360 bits ********
e file argument is implicit in the method call, so we must alter the function signature slightly.
ferror
feof
fflush
fputc
fgetc
fgets
fputs
fseek
Do not use the C++ standard template library, C++ strings library, C standard I/O library or C standard strings functions. You may use malloc to allocate the buffer.

Behavior should be predictable even for files opened in read/write mode. For example, if you read ABC from the file, write XYZ, and then read GHI, the file should end up containing ABCXYZGHI regardless of the buffering mode. Similarly, writing ABCDEFGHI, repositioning the file pointer to the beginning of the file ("rewinding") and writing XYZ should leave XYZDEFGHI in the file regardless of the buffering mode.

Your test program should verify that writing to a read-only file is an error; reading from a write-only file is an error; and that the the code correctly handles the switch between reading and writing in read/write mode.

Your implementation need not worry about thread-safety.

For the purposes of the assignment you only need to implement the default FULL_BUFFER mode. setvbuf is unsupported.

"a" and "a+" modes have complicated semantics and need not be implemented.

You may crash the program if any unsupported feature is called. See undefined behavior.

An application using your library should #include "file.h" and link with file.o (produced by compiling file.cc with the -c flag. Simulate this by putting your implementation and test program in separate directories (use the -I flag when compiling your test program).

Repeat the benchmarking of Lab 3 for your implementation. This means you will be creating two separate executable programs that use your I/O library.

Skeletons have been provided: file-skel.h and file-skel.cc. You may also reuse or cannibalize any of the work that you did for Lab 3.

For reference, a simplified version of fprintf has been provided in the skeleton code.

Don't forget the BUILD script and README files.


ABCDEFGHIJKLMNOPQ
33


Assignment 3: Standard I/O Library
Original author: Munehiro Fukuda

Revisions 2019: Morris Bernstein

As we have seen in Lab 3, the operating system calls open, close, read, write, llseek, etc. provide an effective interface to the filesystem, but have significant limitations. Performance and convenience can be dramatically improved using a higher-level userland library that provides buffering and data-formatting. Furthermore, programs that use the language-defined standard library are more likely to be portable across operating systems.

The standard I/O library of the C language is available to any C or C++ program that includes the stdio.h (cstdio in C++) header file. Since C predates the object-oriented paradigm, the FILE* object is passed in as the first argument to the various functions that implement file operations, but it is fundamentally an operation on an object.

For this assignment, you will implement a class-based version of the C standard I/O library. The constructor will open the file, and the destructor will close the file.

Since constructors and destructors don't return values, we have to alter the semantics slightly: if an error occurs, throw an exception.

Implement the following methods using only the underlying system calls. See the corresponding man pages. Note that the file argument is implicit in the method call, so we must alter the function signature slightly.
ferror
feof
fflush
fputc
fgetc
fgets
fputs
fseek
Do not use the C++ standard template library, C++ strings library, C standard I/O library or C standard strings functions. You may use malloc to allocate the buffer.

Behavior should be predictable even for files opened in read/write mode. For example, if you read ABC from the file, write XYZ, and then read GHI, the file should end up containing ABCXYZGHI regardless of the buffering mode. Similarly, writing ABCDEFGHI, repositioning the file pointer to the beginning of the file ("rewinding") and writing XYZ should leave XYZDEFGHI in the file regardless of the buffering mode.

Your test program should verify that writing to a read-only file is an error; reading from a write-only file is an error; and that the the code correctly handles the switch between reading and writing in read/write mode.

Your implementation need not worry about thread-safety.

For the purposes of the assignment you only need to implement the default FULL_BUFFER mode. setvbuf is unsupported.

"a" and "a+" modes have complicated semantics and need not be implemented.

You may crash the program if any unsupported feature is called. See undefined behavior.

An application using your library should #include "file.h" and link with file.o (produced by compiling file.cc with the -c flag. Simulate this by putting your implementation and test program in separate directories (use the -I flag when compiling your test program).

Repeat the benchmarking of Lab 3 for your implementation. This means you will be creating two separate executable programs that use your I/O library.

Skeletons have been provided: file-skel.h and file-skel.cc. You may also reuse or cannibalize any of the work that you did for Lab 3.

For reference, a simplified version of fprintf has been provided in the skeleton code.

Don't forget the BUILD script and README files.


ABCDEFGHIJKLMNOPQ
34


Assignment 3: Standard I/O Library
Original author: Munehiro Fukuda

Revisions 2019: Morris Bernstein

As we have seen in Lab 3, the operating system calls open, close, read, write, llseek, etc. provide an effective interface to the filesystem, but have significant limitations. Performance and convenience can be dramatically improved using a higher-level userland library that provides buffering and data-formatting. Furthermore, programs that use the language-defined standard library are more likely to be portable across operating systems.

The standard I/O library of the C language is available to any C or C++ program that includes the stdio.h (cstdio in C++) header file. Since C predates the object-oriented paradigm, the FILE* object is passed in as the first argument to the various functions that implement file operations, but it is fundamentally an operation on an object.

For this assignment, you will implement a class-based version of the C standard I/O library. The constructor will open the file, and the destructor will close the file.

Since constructors and destructors don't return values, we have to alter the semantics slightly: if an error occurs, throw an exception.

Implement the following methods using only the underlying system calls. See the corresponding man pages. Note that the file argument is implicit in the method call, so we must alter the function signature slightly.
ferror
feof
fflush
fputc
fgetc
fgets
fputs
fseek
Do not use the C++ standard template library, C++ strings library, C standard I/O library or C standard strings functions. You may use malloc to allocate the buffer.

Behavior should be predictable even for files opened in read/write mode. For example, if you read ABC from the file, write XYZ, and then read GHI, the file should end up containing ABCXYZGHI regardless of the buffering mode. Similarly, writing ABCDEFGHI, repositioning the file pointer to the beginning of the file ("rewinding") and writing XYZ should leave XYZDEFGHI in the file regardless of the buffering mode.

Your test program should verify that writing to a read-only file is an error; reading from a write-only file is an error; and that the the code correctly handles the switch between reading and writing in read/write mode.

Your implementation need not worry about thread-safety.

For the purposes of the assignment you only need to implement the default FULL_BUFFER mode. setvbuf is unsupported.

"a" and "a+" modes have complicated semantics and need not be implemented.

You may crash the program if any unsupported feature is called. See undefined behavior.

An application using your library should #include "file.h" and link with file.o (produced by compiling file.cc with the -c flag. Simulate this by putting your implementation and test program in separate directories (use the -I flag when compiling your test program).

Repeat the benchmarking of Lab 3 for your implementation. This means you will be creating two separate executable programs that use your I/O library.

Skeletons have been provided: file-skel.h and file-skel.cc. You may also reuse or cannibalize any of the work that you did for Lab 3.

For reference, a simplified version of fprintf has been provided in the skeleton code.

Don't forget the BUILD script and README files.


ABCDEFGHIJKLMNOPQ
35


Assignment 3: Standard I/O Library
Original author: Munehiro Fukuda

Revisions 2019: Morris Bernstein

As we have seen in Lab 3, the operating system calls open, close, read, write, llseek, etc. provide an effective interface to the filesystem, but have significant limitations. Performance and convenience can be dramatically improved using a higher-level userland library that provides buffering and data-formatting. Furthermore, programs that use the language-defined standard library are more likely to be portable across operating systems.

The standard I/O library of the C language is available to any C or C++ program that includes the stdio.h (cstdio in C++) header file. Since C predates the object-oriented paradigm, the FILE* object is passed in as the first argument to the various functions that implement file operations, but it is fundamentally an operation on an object.

For this assignment, you will implement a class-based version of the C standard I/O library. The constructor will open the file, and the destructor will close the file.

Since constructors and destructors don't return values, we have to alter the semantics slightly: if an error occurs, throw an exception.

Implement the following methods using only the underlying system calls. See the corresponding man pages. Note that the file argument is implicit in the method call, so we must alter the function signature slightly.
ferror
feof
fflush
fputc
fgetc
fgets
fputs
fseek
Do not use the C++ standard template library, C++ strings library, C standard I/O library or C standard strings functions. You may use malloc to allocate the buffer.

Behavior should be predictable even for files opened in read/write mode. For example, if you read ABC from the file, write XYZ, and then read GHI, the file should end up containing ABCXYZGHI regardless of the buffering mode. Similarly, writing ABCDEFGHI, repositioning the file pointer to the beginning of the file ("rewinding") and writing XYZ should leave XYZDEFGHI in the file regardless of the buffering mode.

Your test program should verify that writing to a read-only file is an error; reading from a write-only file is an error; and that the the code correctly handles the switch between reading and writing in read/write mode.

Your implementation need not worry about thread-safety.

For the purposes of the assignment you only need to implement the default FULL_BUFFER mode. setvbuf is unsupported.

"a" and "a+" modes have complicated semantics and need not be implemented.

You may crash the program if any unsupported feature is called. See undefined behavior.

An application using your library should #include "file.h" and link with file.o (produced by compiling file.cc with the -c flag. Simulate this by putting your implementation and test program in separate directories (use the -I flag when compiling your test program).

Repeat the benchmarking of Lab 3 for your implementation. This means you will be creating two separate executable programs that use your I/O library.

Skeletons have been provided: file-skel.h and file-skel.cc. You may also reuse or cannibalize any of the work that you did for Lab 3.

For reference, a simplified version of fprintf has been provided in the skeleton code.

Don't forget the BUILD script and README files.


ABCDEFGHIJKLMNOPQ
36


Assignment 3: Standard I/O Library
Original author: Munehiro Fukuda

Revisions 2019: Morris Bernstein

As we have seen in Lab 3, the operating system calls open, close, read, write, llseek, etc. provide an effective interface to the filesystem, but have significant limitations. Performance and convenience can be dramatically improved using a higher-level userland library that provides buffering and data-formatting. Furthermore, programs that use the language-defined standard library are more likely to be portable across operating systems.

The standard I/O library of the C language is available to any C or C++ program that includes the stdio.h (cstdio in C++) header file. Since C predates the object-oriented paradigm, the FILE* object is passed in as the first argument to the various functions that implement file operations, but it is fundamentally an operation on an object.

For this assignment, you will implement a class-based version of the C standard I/O library. The constructor will open the file, and the destructor will close the file.

Since constructors and destructors don't return values, we have to alter the semantics slightly: if an error occurs, throw an exception.

Implement the following methods using only the underlying system calls. See the corresponding man pages. Note that the file argument is implicit in the method call, so we must alter the function signature slightly.
ferror
feof
fflush
fputc
fgetc
fgets
fputs
fseek
Do not use the C++ standard template library, C++ strings library, C standard I/O library or C standard strings functions. You may use malloc to allocate the buffer.

Behavior should be predictable even for files opened in read/write mode. For example, if you read ABC from the file, write XYZ, and then read GHI, the file should end up containing ABCXYZGHI regardless of the buffering mode. Similarly, writing ABCDEFGHI, repositioning the file pointer to the beginning of the file ("rewinding") and writing XYZ should leave XYZDEFGHI in the file regardless of the buffering mode.

Your test program should verify that writing to a read-only file is an error; reading from a write-only file is an error; and that the the code correctly handles the switch between reading and writing in read/write mode.

Your implementation need not worry about thread-safety.

For the purposes of the assignment you only need to implement the default FULL_BUFFER mode. setvbuf is unsupported.

"a" and "a+" modes have complicated semantics and need not be implemented.

You may crash the program if any unsupported feature is called. See undefined behavior.

An application using your library should #include "file.h" and link with file.o (produced by compiling file.cc with the -c flag. Simulate this by putting your implementation and test program in separate directories (use the -I flag when compiling your test program).

Repeat the benchmarking of Lab 3 for your implementation. This means you will be creating two separate executable programs that use your I/O library.

Skeletons have been provided: file-skel.h and file-skel.cc. You may also reuse or cannibalize any of the work that you did for Lab 3.

For reference, a simplified version of fprintf has been provided in the skeleton code.

Don't forget the BUILD script and README files.


ABCDEFGHIJKLMNOPQ
37


Assignment 3: Standard I/O Library
Original author: Munehiro Fukuda

Revisions 
 ********************************************* 



 ******* The 16 time fread and read 16384 bits ********
2019: Morris Bernstein

As we have seen in Lab 3, the operating system calls open, close, read, write, llseek, etc. provide an effective interface to the filesystem, but have significant limitations. Performance and convenience can be dramatically improved using a higher-level userland library that provides buffering and data-formatting. Furthermore, programs that use the language-defined standard library are more likely to be portable across operating systems.

The standard I/O library of the C language is available to any C or C++ program that includes the stdio.h (cstdio in C++) header file. Since C predates the object-oriented paradigm, the FILE* object is passed in as the first argument to the various functions that implement file operations, but it is fundamentally an operation on an object.

For this assignment, you will implement a class-based version of the C standard I/O library. The constructor will open the file, and the destructor will close the file.

Since constructors and destructors don't return values, we have to alter the semantics slightly: if an error occurs, throw an exception.

Implement the following methods using only the underlying system calls. See the corresponding man pages. Note that the file argument is implicit in the method call, so we must alter the function signature slightly.
ferror
feof
fflush
fputc
fgetc
fgets
fputs
fseek
Do not use the C++ standard template library, C++ strings library, C standard I/O library or C standard strings functions. You may use malloc to allocate the buffer.

Behavior should be predictable even for files opened in read/write mode. For example, if you read ABC from the file, write XYZ, and then read GHI, the file should end up containing ABCXYZGHI regardless of the buffering mode. Similarly, writing ABCDEFGHI, repositioning the file pointer to the beginning of the file ("rewinding") and writing XYZ should leave XYZDEFGHI in the file regardless of the buffering mode.

Your test program should verify that writing to a read-only file is an error; reading from a write-only file is an error; and that the the code correctly handles the switch between reading and writing in read/write mode.

Your implementation need not worry about thread-safety.

For the purposes of the assignment you only need to implement the default FULL_BUFFER mode. setvbuf is unsupported.

"a" and "a+" modes have complicated semantics and need not be implemented.

You may crash the program if any unsupported feature is called. See undefined behavior.

An application using your library should #include "file.h" and link with file.o (produced by compiling file.cc with the -c flag. Simulate this by putting your implementation and test program in separate directories (use the -I flag when compiling your test program).

Repeat the benchmarking of Lab 3 for your implementation. This means you will be creating two separate executable programs that use your I/O library.

Skeletons have been provided: file-skel.h and file-skel.cc. You may also reuse or cannibalize any of the work that you did for Lab 3.

For reference, a simplified version of fprintf has been provided in the skeleton code.

Don't forget the BUILD script and README files.


ABCDEFGHIJKLMNOPQ
38


Assignment 3: Standard I/O Library
Original author: Munehiro Fukuda

Revisions 2019: Morris Bernstein

As we have seen in Lab 3, the operating system calls open, close, read, write, llseek, etc. provide an effective interface to the filesystem, but have significant limitations. Performance and convenience can be dramatically improved using a higher-level userland library that provides buffering and data-formatting. Furthermore, programs that use the language-defined standard library are more likely to be portable across operating systems.

The standard I/O library of the C language is available to any C or C++ program that includes the stdio.h (cstdio in C++) header file. Since C predates the object-oriented paradigm, the FILE* object is passed in as the first argument to the various functions that implement file operations, but it is fundamentally an operation on an object.

For this assignment, you will implement a class-based version of the C standard I/O library. The constructor will open the file, and the destructor will close the file.

Since constructors and destructors don't return values, we have to alter the semantics slightly: if an error occurs, throw an exception.

Implement the following methods using only the underlying system calls. See the corresponding man pages. Note that the file argument is implicit in the method call, so we must alter the function signature slightly.
ferror
feof
fflush
fputc
fgetc
fgets
fputs
fseek
Do not use the C++ standard template library, C++ strings library, C standard I/O library or C standard strings functions. You may use malloc to allocate the buffer.

Behavior should be predictable even for files opened in read/write mode. For example, if you read ABC from the file, write XYZ, and then read GHI, the file should end up containing ABCXYZGHI regardless of the buffering mode. Similarly, writing ABCDEFGHI, repositioning the file pointer to the beginning of the file ("rewinding") and writing XYZ should leave XYZDEFGHI in the file regardless of the buffering mode.

Your test program should verify that writing to a read-only file is an error; reading from a write-only file is an error; and that the the code correctly handles the switch between reading and writing in read/write mode.

Your implementation need not worry about thread-safety.

For the purposes of the assignment you only need to implement the default FULL_BUFFER mode. setvbuf is unsupported.

"a" and "a+" modes have complicated semantics and need not be implemented.

You may crash the program if any unsupported feature is called. See undefined behavior.

An application using your library should #include "file.h" and link with file.o (produced by compiling file.cc with the -c flag. Simulate this by putting your implementation and test program in separate directories (use the -I flag when compiling your test program).

Repeat the benchmarking of Lab 3 for your implementation. This means you will be creating two separate executable programs that use your I/O library.

Skeletons have been provided: file-skel.h and file-skel.cc. You may also reuse or cannibalize any of the work that you did for Lab 3.

For reference, a simplified version of fprintf has been provided in the skeleton code.

Don't forget the BUILD script and README files.

ABCDEFGHIJKLMNOPQ
39


Assignment 3: Standard I/O Library
Original author: Munehiro Fukuda

Revisions 2019: Morris Bernstein

As we have seen in Lab 3, the operating system calls open, close, read, write, llseek, etc. provide an effective interface to the filesystem, but have significant limitations. Performance and convenience can be dramatically improved using a higher-level userland library that provides buffering and data-formatting. Furthermore, programs that use the language-defined standard library are more likely to be portable across operating systems.

The standard I/O library of the C language is available to any C or C++ program that includes the stdio.h (cstdio in C++) header file. Since C predates the object-oriented paradigm, the FILE* object is passed in as the first argument to the various functions that implement file operations, but it is fundamentally an operation on an object.

For this assignment, you will implement a class-based version of the C standard I/O library. The constructor will open the file, and the destructor will close the file.

Since constructors and destructors don't return values, we have to alter the semantics slightly: if an error occurs, throw an exception.

Implement the following methods using only the underlying system calls. See the corresponding man pages. Note that the file argument is implicit in the method call, so we must alter the function signature slightly.
ferror
feof
fflush
fputc
fgetc
fgets
fputs
fseek
Do not use the C++ standard template library, C++ strings library, C standard I/O library or C standard strings functions. You may use malloc to allocate the buffer.

Behavior should be predictable even for files opened in read/write mode. For example, if you read ABC from the file, write XYZ, and then read GHI, the file should end up containing ABCXYZGHI regardless of the buffering mode. Similarly, writing ABCDEFGHI, repositioning the file pointer to the beginning of the file ("rewinding") and writing XYZ should leave XYZDEFGHI in the file regardless of the buffering mode.

Your test program should verify that writing to a read-only file is an error; reading from a write-only file is an error; and that the the code correctly handles the switch between reading and writing in read/write mode.

Your implementation need not worry about thread-safety.

For the purposes of the assignment you only need to implement the default FULL_BUFFER mode. setvbuf is unsupported.

"a" and "a+" modes have complicated semantics and need not be implemented.

You may crash the program if any unsupported feature is called. See undefined behavior.

An application using your library should #include "file.h" and link with file.o (produced by compiling file.cc with the -c flag. Simulate this by putting your implementation and test program in separate directories (use the -I flag when compiling your test program).

Repeat the benchmarking of Lab 3 for your implementation. This means you will be creating two separate executable programs that use your I/O library.

Skeletons have been provided: file-skel.h and file-skel.cc. You may also reuse or cannibalize any of the work that you did for Lab 3.

For reference, a simplified version of fprintf has been provided in the skeleton code.

Don't forget the BUILD script and README files.


ABCDEFGHIJKLMNOPQ
40


Assignment 3: Standard I/O Library
Original author: Munehiro Fukuda

Revisions 2019: Morris Bernstein

As we have seen in Lab 3, the operating system calls open, close, read, write, llseek, etc. provide an effective interface to the filesystem, but have significant limitations. Performance and convenience can be dramatically improved using a higher-level userland library that provides buffering and data-formatting. Furthermore, programs that use the language-defined standard library are more likely to be portable across operating systems.

The standard I/O library of the C language is available to any C or C++ program that includes the stdio.h (cstdio in C++) header file. Since C predates the object-oriented paradigm, the FILE* object is passed in as the first argument to the various functions that implement file operations, but it is fundamentally an operation on an object.

For this assignment, you will implement a class-based version of the C standard I/O library. The constructor will open the file, and the destructor will close the file.

Since constructors and destructors don't return values, we have to alter the semantics slightly: if an error occurs, throw an exception.

Implement the following methods using only the underlying system calls. See the corresponding man pages. Note that the file argument is implicit in the method call, so we must alter the function signature slightly.
ferror
feof
fflush
fputc
fgetc
fgets
fputs
fseek
Do not use the C++ standard template library, C++ strings library, C standard I/O library or C standard strings functions. You may use malloc to allocate the buffer.

Behavior should be predictable even for files opened in read/write mode. For example, if you read ABC from the file, write XYZ, and then read GHI, the file should end up containing ABCXYZGHI regardless of the buffering mode. Similarly, writing ABCDEFGHI, repositioning the file pointer to the beginning of the file ("rewinding") and writing XYZ should leave XYZDEFGHI in the file regardless of the buffering mode.

Your test program should verify that writing to a read-only file is an error; reading from a write-only file is an error; and that the the code correctly handles the switch between reading and writing in read/write mode.

Your implementation need not worry about thread-safety.

For the purposes of the assignment you only need to implement the default FULL_BUFFER mode. setvbuf is unsupported.

"a" and "a+" modes have complicated semantics and need not be implemented.

You may crash the program if any unsupported feature is called. See undefined behavior.

An application using your library should #include "file.h" and link with file.o (produced by compiling file.cc with the -c flag. Simulate this by putting your implementation and test program in separate directories (use the -I flag when compiling your test program).

Repeat the benchmarking of Lab 3 for your implementation. This means you will be creating two separate executable programs that use your I/O library.

Skeletons have been provided: file-skel.h and file-skel.cc. You may also reuse or cannibalize any of the work that you did for Lab 3.

For reference, a simplified version of fprintf has been provided in the skeleton code.

Don't forget the BUILD script and README files.


ABCDEFGHIJKLMNOPQ
41


Assignment 3: Standard I/O Library
Original author: Munehiro Fukuda

Revisions 2019: Morris Bernstein

As we have seen in Lab 3, the operating system calls open, close, read, write, llseek, etc. provide an effective interface to the filesystem, but have significant limitations. Performance and convenience can be dramatically improved using a higher-level userland library that provides buffering and data-formatting. Furthermore, programs that use the language-defined standard library are more likely to be portable across operating systems.

The standard I/O library of the C language is available to any C or C++ program that includes the stdio.h (cstdio in C++) header file. Since C predates the object-oriented paradigm, the FILE* object is passed in as the first argument to the various functions that implement file operations, but it is fundamentally an operation on an object.

For this assignment, you will implement a class-based version of the C standard I/O library. The constructor will open the file, and the destructor will close the file.

Since constructors and destructors don't return values, we have to alter the semantics slightly: if an error occurs, throw an exception.

Implement the following methods using only the underlying system calls. See the corresponding man pages. Note that the file argument is implicit in the method call, so we must alter the function signature slightly.
ferror
feof
fflush
fputc
fgetc
fgets
fputs
fseek
Do not use the C++ standard template library, C++ strings library, C standard I/O library or C standard strings functions. You may use malloc to allocate the buffer.

Behavior should be predictable even for files opened in read/write mode. For example, if you read ABC from the file, write XYZ, and then read GHI, the file should end up containing ABCXYZGHI regardless of the buffering mode. Similarly, writing ABCDEFGHI, repositioning the file pointer to the beginning of the file ("rewinding") and writing XYZ should leave XYZDEFGHI in the file regardless of the buffering mode.

Your test program should verify that writing to a read-only file is an error; reading from a write-only file is an error; and that the the code correctly handles the switch between reading and writing in read/write mode.

Your implementation need not worry about thread-safety.

For the purposes of the assignment you only need to implement the default FULL_BUFFER mode. setvbuf is unsupported.

"a" and "a+" modes have complicated semantics and need not be implemented.

You may crash the program if any unsupported feature is called. See undefined behavior.

An application using your library should #include "file.h" and link with file.o (produced by compiling file.cc with the -c flag. Simulate this by putting your implementation and test program in separate directories (use the -I flag when compiling your test program).

Repeat the benchmarking of Lab 3 for your implementation. This means you will be creating two separate executable programs that use your I/O library.

Skeletons have been provided: file-skel.h and file-skel.cc. You may also reuse or cannibalize any of the work that you did for Lab 3.

For reference, a simplified ve
 ********************************************* 



 ********************************************* 


  ----- test write to read only file -----
test ferror:     Success!


 -------------- test rw file --------------- 
 ** test fgetc for 3 times ** 
test fgetc:     Success! 
A
test fgetc:     Success! 
B
test fgetc:     Success! 
C
 ** test fputc for 3 times ** 
test fputc:    Success! 
test fputc:    Success! 
test fputc:    Success! 
 ** test fgets with getting 16 bits ** 
test fgets :    Success! 
fgets : 
GHIJKLMNOPQ
0



 ** test fputs : string should store at the position (3+3+16 = 21) ** 
 test fputs :    Success! 
 ** test fread: 32 numbers' data with each size 8 bit **
test fread :     Success! 
fread : 
nment 3: Standard I/O Library
Original author: Munehiro Fukuda

Revisions 2019: Morris Bernstein

As we have seen in Lab 3, the operating system calls open, close, read, write, llseek, etc. provide an effective interface to the filesystem, but have signifi
test fwrite :     Success! 


 -------------- test write-only file  -------------- 
 ** test fputc for 3 times ** 
test fputc :    Success! 
test fputc :    Success! 
test fputc :    Success! 
 ** test fputs **
test fputs :    Success! 
 ** test fwrite **
test fwrite:    Success!
  ----------  test read to write only file -----------
test ferror :    Success! 

 ------- test contructor exception error ---------
